{"meta":{"title":"欢迎来玩哦!","subtitle":"学吧 学无止境 太深了!","description":"","author":"1eng","url":"http://perthinking.com","root":"/"},"posts":[{"tags":[],"title":"代码审计+无数字字母webshell+windowsFindFirstfile利用+xctf-finals Web-lfi2019","date":"2020/05/05","text":"审计源码意思就是让上传个马,然后包含过去读flag 要把一些无关紧要的代码略过 1)实现put,get功能的代码:1234567891011121314151617181920212223242526272829303132333435$parsed_url = explode(\"&\", $_SERVER['QUERY_STRING']); if(count($parsed_url) >= 2){​ header(\"Content-Type:text/json\");​ switch($parsed_url[0]){​ case \"get\":​ $get = new Get($parsed_url[1]);​ $data = $get->get();​ break;​ case \"put\":​ $put = new Put($parsed_url[1], $_POST);​ $data = $put->put();​ break;​ default:​ $data = [\"msg\" => \"Invalid data.\"];​ break;​ }​ die(json_encode($data)); } 2)get功能块:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Get {​ protected function nanahira(){​ // senpai notice me //​ function exploit($data){​ $exploit = new System();​ }​ $_GET['trigger'] && !@@@@@@@@@@@@@exploit($$$$$$_GET['leak']['leak']);​ }​ private $filename;​ function __construct($filename){​ $this->filename = path_sanitizer($filename);​ }​ function get(){​ if($this->filename === false){​ return [\"msg\" => \"blocked by path sanitizer\", \"type\" => \"error\"];​ }​ // wtf???? //​ if(!@file_exists($this->filename)){​ // index files are *completely* disabled. //​ if(stripos($this->filename, \"index\") !== false){​ return [\"msg\" => \"you cannot include index files!\", \"type\" => \"error\"];​ } ​ // hardened sanitizer spawned. thus we sense ambiguity //​ $read_file = \"./files/\" . $this->filename;​ $read_file_with_hardened_filter = \"./files/\" . path_sanitizer($this->filename, true); ​ if($read_file === $read_file_with_hardened_filter ||​ @file_get_contents($read_file) === @file_get_contents($read_file_with_hardened_filter)){​ return [\"msg\" => \"request blocked\", \"type\" => \"error\"];​ }​ // .. and finally, include *un*exploitable file is included. //​ @include(\"./files/\" . $this->filename);​ return [\"type\" => \"success\"];​ }else{​ return [\"msg\" => \"invalid filename (wtf)\", \"type\" => \"error\"];​ }​ } } 3)put功能块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Put {​ protected function nanahira(){​ // senpai notice me //​ function exploit($data){​ $exploit = new System();​ }​ $_GET['trigger'] && !@@@@@@@@@@@@@exploit($$$$$$_GET['leak']['leak']);​ }​ private $filename;​ private $content;​ private $dir = \"./files/\";​ function __construct($filename, $data){​ global $seed;​ if((string)$filename === (string)@path_sanitizer($data['filename'])){​ $this->filename = (string)$filename;​ }else{​ $this->filename = false;​ }​ $this->content = (string)@code_sanitizer($data['content']);​ }​ function put(){​ // just another typical file insertion //​ if($this->filename === false){​ return [\"msg\" => \"blocked by path sanitizer\", \"type\" => \"error\"];​ }​ // check if file exists //​ if(file_exists($this->dir . $this->filename)){​ return [\"msg\" => \"file exists\", \"type\" => \"error\"];​ }​ file_put_contents($this->dir . $this->filename, $this->content);​ // just check if file is written. hopefully. //​ if(@file_get_contents($this->dir . $this->filename) == \"\"){​ return [\"msg\" => \"file not written.\", \"type\" => \"error\"];​ }​ return [\"type\" => \"success\"];​ } } 4)过滤函数:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145 function rrmdir($dir, $depth=0){ ​ if (is_dir($dir)){​ $objects = scandir($dir); ​ foreach ($objects as $object){ ​ if ($object != \".\" && $object != \"..\"){ ​ if(is_dir($dir.\"/\".$object))​ rrmdir($dir.\"/\".$object, $depth + 1);​ else​ unlink($dir.\"/\".$object); ​ }​ }​ }​ if($depth != 0) rmdir($dir); } function countdir($dir){​ if (is_dir($dir)){​ $objects = scandir($dir);​ foreach ($objects as $object){ ​ if ($object != \".\" && $object != \"..\"){ ​ $count += 1;​ if(is_dir($dir.\"/\".$object))​ $count += countdir($dir.\"/\".$object);​ }​ }​ }​ return $count; } var_dump(countdir(\"./files\")); if(countdir(\"./files/\") >= 100) @rrmdir(\"./files/\"); // Here, kawaii path-san for you! // function path_sanitizer($dir, $harden=false){​ $dir = (string)$dir;​ $dir_len = strlen($dir);​ // Deny LFI/RFI/XSS //​ $filter = ['.', './', '~', '.\\\\', '#', ''];​ foreach($filter as $f){​ if(stripos($dir, $f) !== false){​ return false;​ }​ }​ // Deny SSRF and all possible weird bypasses //​ $stream = stream_get_wrappers();​ $stream = array_merge($stream, stream_get_transports());​ $stream = array_merge($stream, stream_get_filters());​ foreach($stream as $f){​ $f_len = strlen($f);​ if(substr($dir, 0, $f_len) === $f){​ return false;​ }​ }​ // Deny length //​ if($dir_len >= 128){​ return false;​ }​ // Easy level hardening //​ if($harden){​ $harden_filter = [\"/\", \"\\\\\"];​ foreach($harden_filter as $f){​ $dir = str_replace($f, \"\", $dir);​ }​ } ​ // Sanitize feature is available starting from the medium level //​ return $dir; } // The new kakkoii code-san is re-implemented. // function code_sanitizer($code){​ // Computer-chan, please don't speak english. Speak something else! //​ $code = preg_replace(\"/[^!@#$%\\^&*\\_?+\\.\\-\\\\\\'\\\"\\=\\(\\)\\[\\]\\;]/u\", \"*Nope*\", (string)$code);​ return $code; } 5)还有这段代码:12345678910111213141516171819202122232425262728293031323334353637@require('flag.php');$seed = md5(rand(PHP_INT_MIN,PHP_INT_MAX)); if($flag === $_GET['trigger']){​ die(hash(\"sha256\", $seed . $flag)); } class System {​ function __destruct(){​ global $seed;​ // ain't Argon2, ain't pbkdf2. what could go wrong?​ $flag = hash('sha256', $seed);​ if($_GET[$flag]){​ @system($_GET[$flag]);​ }else{​ @unserialize($_SESSION[$flag]);​ }​ } } 这里是迷惑点,拿不到flag 2.分析put要过滤的点首先这个条件成立才能put文件 if((string)$filename === (string)@path_sanitizer($data['filename'])) 文件名不能包含这些符号 1234567891011$filter = ['.', './', '~', '.\\\\', '#', ''];​ foreach($filter as $f){​ if(stripos($dir, $f) !== false){​ return false;​ }​ } 长度限制: 12345if($dir_len >= 128){​ return false;​ } content的限制: $code = preg_replace(\"/[^!@#$%\\^&*\\_?+\\.\\-\\\\\\'\\\"\\=\\(\\)\\[\\]\\;]/u\", \"*Nope*\", (string)$code); 本地测试下: 1234567$a=@$_POST[a];//$a = preg_replace(\"/[^!@#$%\\^&*\\_?]/u\", \"h\", $a);$a = preg_replace(\"/[^!@#$%\\^&*\\_?+\\.\\-\\\\\\'\\\"\\=\\(\\)\\[\\]\\;]/u\", \"h\", $a);echo $a; 多了四个 hhhh 输入的字符没有被替换 怎么多了四个hhhh? 发现 应该是这样的,它会默认匹配 /r /n 属于一个字节,而汉字匹配的话是两个字节 所以这样的话就是四个字节了 替换后就变成了四个hhhh 再输入一个回车试下: 假如一句话是 虽然添加了几个字符 但并不影响php代码的执行 总结来说 就是让上传一个没有字母和数字的webshell 3.分析get要过滤的点 1)这个函数解析url中get参数 explode(“&”, $_SERVER[‘QUERY_STRING’]); 2)看过滤点: $read_file = “./files/“ . $this->filename; ​ $read_file_with_hardened_filter = “./files/“ . path_sanitizer($this->filename, true); ​ if($read_file === $read_file_with_hardened_filter || ​ @file_get_contents($read_file) === @file_get_contents($read_file_with_hardened_filter)){ ​ return [“msg” => “request blocked”, “type” => “error”]; ​ } 首先看这个函数 path_sanitizer($this->filename, true) –> if($harden){ ​ $harden_filter = [“/“, “\\“]; ​ foreach($harden_filter as $f){ ​ $dir = str_replace($f, “”, $dir); ​ } ​ } 它将文件名中 / \\替换为空 然后这个if判断为真的话不能包含文件 if($read_file === $read_file_with_hardened_filter || ​ @file_get_contents($read_file) === @file_get_contents($read_file_with_hardened_filter)) 也就是说包含的文件名必须加 / 或 \\ 同时文件内容也是不一样的 比如上传一个test 然后包含文件时是test\\ -> test不等于test\\ 并且 file_get_contents(‘test')不等于file_get_contents(‘test’) 那么这个判断就可以绕过了 现在测试一下 ![计算机生成了可选文字: POST/?puaaa TP/1.1 bl-旧0上cn x64）AppleWebKit/537.36 RemiCollet， 〈/table> 〈table) Kova Host:248t Accept:/ 一s915一40bb一87a9一89b6d684sb1t．node3. X-Requested-With::dILHttpRequest User-Agent：瞓ozilla/5．0(WindowsNT1生0in64， Gecko)Come/83987．149Safari/537.36 (KHTML, 1让e Referer:http：//248t2d25一s915一40bb一87a9一89b6d684sb1t．node3.buuoj.on/ Accept—Encoding:gZ1P，deflate Accept-Language:zh-CN，Zh，q=O.9 ConnectIon:I C0Se Content-Length：26 trclass:h SucCeSS}](file:///C:/Users/aleng/AppData/Local/Temp/msohtmlclip1/01/clip_image009.png) 再包含下 ![计算机生成了可选文字: GET/?getaaa\\ Host:248t Accept:/ bl-旧0上cn x64）AppleWebKit/537.36 RemiCollet， 〈/table> 〈table) FerencKovacs〈/tc 一e15一40bb一87a9一89b6d684sb1t．node3. X-Requested-With: User-Agent：瞓0zi11 ttpRequest (WindowsNT10in64， (KHTML, 1让e Gecko)Come/83987．49Safari/537.36 Referer:http://248f2d25- 15一40bb一87a9一89b6d684sb1t．node3.buuoj.on/ Accept—Encoding:gZ1P，defte Accept-Language:zh-CN，Zh，q ConnectIon:I C0Se Content-Length：2 “2“〉譽eb！ trclass:h NetworkInfras e>WindowsInfras 〈1]2〉P》License 〈table) ()rclass-v〉〈td〉 〈p〉 Thisprogram1Sfreesoftware theternE0theP〗Licensea distribution1nthe11e：LIC 〈/p〉 〈p〉Tsprogramsdistributed 厦．WARRAMY;withouteventhe FORAPARTICULARPURPOSE. 〈/p〉 〈p〉Iyoudidnotrece1veaCOI aboutp}〗licenslng,pleaseC0 〈/p〉 〈/table> SucCeSS}](file:///C:/Users/aleng/AppData/Local/Temp/msohtmlclip1/01/clip_image010.png) 可以发现 成功include 但是文件内容没有读取 @include(“./files/“ . $this->filename); -> ./files/test\\ 它包含的是这个文件 而我们上传的文件是这样的: ./files/test 所以文件并不能读取 4.windows FindFirstFile利用 本地测试 本题环境是 windows 所以我们可以上传 文件名为 “/test 绕过: $read_file = “./files/“ . $this->filename; // ./files/./test $read_file_with_hardened_filter = “./files/“ . path_sanitizer($this->filename, true); // ./files/.test @file_get_contents($read_file) //实际获取内容 @file_get_contents($read_file_with_hardened_filter) // 文件不存在 ![计算机生成了可选文字: POST/?put&”/abcHTTP/I.1 Host:248t2d25一s915一40bb一87a9一89b6d684sb1t．node3. Accept:/ X-Requested-With::dILHttpRequest User-Agent：Mozilla/5.0(WindowsNT1生0in64， Gecko)Come/83987．149Safari/537.36 bl-旧0上cn x64）AppleWebKit/537.36 (KHTML, 1让e Referer:http：//248t2d25一s915一40bb一87a9一89b6d684sb1t．node3.buuoj.on/ RemiCollet， 〈/table> 〈table) trclass:h int(l) SucCeSS}](file:///C:/Users/aleng/AppData/Local/Temp/msohtmlclip1/01/clip_image015.png) ![计算机生成了可选文字: GET/?get&”/abcHTTP/I.1 Host:248t2d25一s915一40bb一87a9一89b6d684sb1t．node3. Accept:/ X-Requested-With::dILHttpRequest User-Agent：Mozilla/5.0(WindowsNT1生0in64， Gecko)Come/83987．149Safari/537.36 bl-旧0上cn x64）AppleWebKit/537.36 (KHTML, 1让e Referer:http：//248t2d25一s915一40bb一87a9一89b6d684sb1t．node3.buuoj.on/ Accept—Encoding:gZ1P，deflate Accept-Language:zh-CN，Zh，q=O.9 ConnectIon:I C0Se Content-Length：32 Content—Tne:appIcation/x filename:/abc&content= “1encoded RemiCollet，FerencKovacs〈/td>〈/tr> 〈/table> 〈table) trclass:hWebsitesandInfrastru 〈table) FerencKovacs〈/td (KHTML, 1让e “2”>Webs trclass:h 〈/div〉〈/body〉〈/1]tml〉№儿L SucCeSS}](file:///C:/Users/aleng/AppData/Local/Temp/msohtmlclip1/01/clip_image017.png) 然后包含 ![计算机生成了可选文字: GET/?get&”/qq HTTP/I.1 Host:41adf81a一327t一4b91一85b8一bf812d41f3b1.node3. Content¯Length． 3253 Accept:/ X-Requested-With::dILHttpRequest User-Agent：Mozilla/5.0(WindowsNT1生0in64， Gecko)Come/83987．149Safari/537.36 Content—Tne:appIcation/xform¯urlencoded EventMaintainersDamien bl-旧0上 x64）AppleWebKit/537.36 charset=UTF- (KHTML, 1让e Brown Network Windows 〈/table> 〈1]2〉P》License 〈table) ()rclass-v〉〈td〉 〈p〉 Infrastructure Infrastructure int(l) orha Array","permalink":"http://perthinking.com/CTF/2/","photos":[]},{"tags":[],"title":"哈希长度扩展攻击","date":"2020/04/19","text":"攻击的常见来源:大多数网站有下载文件的选项,它会判断你是否具有权限下载这个文件,就会对你想要下载的任意文件名进行类似于MD5,Sha等算法的hash,例如你想要下载hash=test.pdf%00../../../etc/password它就可能执行判断语句:if ($sig === md5($salt.$name))但是这样的话就有可能被绕过的风险 MD5算法解析:Md5的典型应用是对一段字符串产生指纹,防止被篡改.就相当于每个人都有自己独立的指纹(在算法里面是可以绕过的)MD5以多个512位(64个字节)分组来处理文本,每组16个32位(4个字节)子分组.算法输出由32位分组组成.当每一个块(512位分组)计算完成后,四个寄存器的值就被更新,如果还存在下一个块,就会在被更新的寄存器上继续计算,直到所有块被计算完毕,四个寄存器的十六进制值连接起来就是MD5当被hash的字符串长度不足512bit时,就得部位 部位(补bit和补长度)判断len(str) % 512 = 448 ,如果不是的话,就对它进行部位,例如test为四个字节,要让条件成立的话,就必须补(448-4*8)个bit,首先补一个二进制位上的一个1,接着在后面补0.然后补剩下的64bit的长度,这个长度就是字符串的长度,如果超出64位,就取低64位例如补完一个块可能是这样的: Str + '\\x80' + '\\x00'*n + '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' 其中算法的补位这部分,就是实现长度扩展攻击的关键,所以部位肯定是可控的 攻击原理:构造部位: 假如有一个下载文件的题目,已知字符串 ‘secret+test.pdf’的hash值,secret的长度为10,要求你下载这个网站的其它文件 实现攻击的第一步,将secret+test.pdf补足到64字节 Len(secret) + len(\"test.pdf\") + len(padding) + 8 = 64 可以计算出padding的长度为64-8-10-8=38 先补一个二进制位上的1即”\\x80” 和37个0即”\\x00”37,于是变成了这样: Secret + \"test.pdf\" + \"\\x80\" + \"\\x00\"*37 + 8 再补后面的8个字节,这8个字节的内容是len(secret+test.pdf)即18(144位),换算成16进制就是\\x90 + 7个二进制位上的0 所以变成: Secret + \"test.pdf\" + \"\\x80\" + \"\\x00\"*37 + \"\\x90\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" ​ 构造hash:用工具爆破即可 所以:构造补位就是为了不用计算第一块的值,只需要计算第二块或者第二块以后的值,而初始值就是原来的hash(这个知道就行了),然后用构造的字符串计算出新的hash 题目主要源码: 1234567891011121314if (!empty($_COOKIE[\"getmein\"])) { if (urldecode($username) === \"admin\" && urldecode($password) != \"admin\") { if ($COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password))) { echo \"Congratulations! You are a registered user.\\n\"; die (\"The flag is \". $flag); } else { die (\"Your cookies don't match up! STOP HACKING THIS SITE.\"); } } else { die (\"You are not an admin! LEAVE.\"); }} 绕过条件:username=admin password!=admin $COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password))用脚本爆破是不可能的,因为我尝试过了所以用到了hash长度扩展攻击,条件符合直接上HashPump脚本","permalink":"http://perthinking.com/CTF/1/","photos":[]}],"categories":[],"tags":[]}